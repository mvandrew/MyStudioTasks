
////////////////////////////////////////////////////////////////////////////////
// Подсистема "Работа с файлами".
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

Процедура ОбновитьПрисоединенныйФайл(Знач ПрисоединенныйФайл, Знач ИнформацияОФайле) Экспорт
	
	РаботаСФайлами.ОбновитьФайл(ПрисоединенныйФайл, ИнформацияОФайле);
	
КонецПроцедуры

// См. эту процедуру в модуле ПрисоединенныеФайлы.
Процедура ОпределитьФормуПрисоединенногоФайла(Источник,
                                                      ВидФормы,
                                                      Параметры,
                                                      ВыбраннаяФорма,
                                                      ДополнительнаяИнформация,
                                                      СтандартнаяОбработка) Экспорт
	
	РаботаСФайлами.ОпределитьФормуПрисоединенногоФайла(Источник,
		ВидФормы,
		Параметры,
		ВыбраннаяФорма,
		ДополнительнаяИнформация,
		СтандартнаяОбработка);
		
КонецПроцедуры

// См. функцию ДобавитьПрисоединенныйФайл в модуле РаботаСФайлами.
Функция ДобавитьФайл(ПараметрыФайла,
                     Знач АдресФайлаВоВременномХранилище,
                     Знач АдресВременногоХранилищаТекста = "",
                     Знач Описание = "") Экспорт
	
	Возврат РаботаСФайлами.ДобавитьФайл(
		ПараметрыФайла,
		АдресФайлаВоВременномХранилище,
		АдресВременногоХранилищаТекста,
		Описание);
	
КонецФункции

// Процедура добавляет настройки специфичные для подсистемы Работа с файлами.
//
// Параметры:
//  ОбщиеНастройки        - Структура - настройки общие для всех пользователей.
//  ПерсональныеНастройки - Структура - настройки различные для разных пользователей.
//  
Процедура ДобавитьНастройкиРаботыСФайлами(ОбщиеНастройки, ПерсональныеНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПерсональныеНастройки.Вставить("ДействиеПоДвойномуЩелчкуМыши", ДействиеПоДвойномуЩелчкуМыши());
	ПерсональныеНастройки.Вставить("СпособСравненияВерсийФайлов",  СпособСравненияВерсийФайлов());
	
	ПерсональныеНастройки.Вставить("СпрашиватьРежимРедактированияПриОткрытииФайла",
		СпрашиватьРежимРедактированияПриОткрытииФайла());
	
	ПерсональныеНастройки.Вставить("ЭтоПолноправныйПользователь",
		Пользователи.ЭтоПолноправныйПользователь(,, Ложь));
	
	ПоказыватьЗанятыеФайлыПриЗавершенииРаботы = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить(
		"НастройкиПрограммы", "ПоказыватьЗанятыеФайлыПриЗавершенииРаботы");
	
	Если ПоказыватьЗанятыеФайлыПриЗавершенииРаботы = Неопределено Тогда
		ПоказыватьЗанятыеФайлыПриЗавершенииРаботы = Истина;
		
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить(
			"НастройкиПрограммы",
			"ПоказыватьЗанятыеФайлыПриЗавершенииРаботы",
			ПоказыватьЗанятыеФайлыПриЗавершенииРаботы);
	КонецЕсли;
	
	ПерсональныеНастройки.Вставить("ПоказыватьЗанятыеФайлыПриЗавершенииРаботы",
		ПоказыватьЗанятыеФайлыПриЗавершенииРаботы);
	
	ПерсональныеНастройки.Вставить("ПоказыватьКолонкуРазмер", ПолучитьПоказыватьКолонкуРазмер());
	
КонецПроцедуры

// Вернет размер файлов на томе - в байтах.
Функция ПодсчитатьРазмерФайловНаТоме(СсылкаТома) Экспорт
	
	Если Не ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат 0;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ЕСТЬNULL(СУММА(Версии.Размер), 0) КАК РазмерФайлов
	|ИЗ
	|	Справочник.ВерсииФайлов КАК Версии
	|ГДЕ
	|	Версии.Том = &Том";
	
	Запрос.Параметры.Вставить("Том", СсылкаТома);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		РазмерФайловВТоме = Число(Выборка.РазмерФайлов);
	КонецЕсли;
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	ВсеИменаСправочников = Новый Соответствие;
	
	Запрос = Новый Запрос;
	Запрос.Параметры.Вставить("Том", СсылкаТома);
	
	Для Каждого Тип Из ТипыВладельцев Цикл
		
		Если Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
			Продолжить;
		КонецЕсли;
		
		ИменаСправочников = РаботаСФайламиСлужебный.ИменаСправочниковХраненияФайлов(Тип, Истина);
		
		Для каждого КлючИЗначение Из ИменаСправочников Цикл
			Если ВсеИменаСправочников[КлючИЗначение.Ключ] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ИмяСправочникаПрисоединенныхФайлов = КлючИЗначение.Ключ;
			ВсеИменаСправочников.Вставить(КлючИЗначение.Ключ, Истина);
		
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ЕСТЬNULL(СУММА(ПрисоединенныеФайлы.Размер), 0) КАК РазмерФайлов
			|ИЗ
			|	&ИмяСправочника КАК ПрисоединенныеФайлы
			|ГДЕ
			|	ПрисоединенныеФайлы.Том = &Том";
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяСправочника",
				"Справочник." + ИмяСправочникаПрисоединенныхФайлов);
			
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				РазмерФайловВТоме = РазмерФайловВТоме + Выборка.РазмерФайлов;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
	Возврат РазмерФайловВТоме;
	
КонецФункции

// Читает кодировку версии файла.
//
// Параметры:
// ВерсияСсылка - ссылка на версию файла.
//
// Возвращаемое значение:
//   Строка кодировки
Функция ПолучитьКодировкуВерсииФайла(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.КодировкиФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Файл = ВерсияСсылка;
	МенеджерЗаписи.Прочитать();
	
	Возврат МенеджерЗаписи.Кодировка;
	
КонецФункции

// Получает данные файла и его двоичные данные.
//
// Параметры:
//  ФайлИлиВерсияСсылка - СправочникСсылка.Файлы, СправочникСсылка.ВерсииФайлов - файл или версия файла.
//  АдресПодписи - Строка - навигационная ссылка, содержащая адрес файла подписи во временном хранилище.
//  ИдентификаторФормы  - УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Структура - ДанныеФайла и сам файл как ДвоичныеДанные и подпись файла как ДвоичныеДанные.
//
Функция ДанныеФайлаИДвоичныеДанные(ФайлИлиВерсияСсылка, АдресПодписи = Неопределено, ИдентификаторФормы = Неопределено) Экспорт
	
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(ФайлИлиВерсияСсылка));
	ЭтоСправочникФайлов = ОбщегоНазначения.ЕстьРеквизитОбъекта("ВладелецФайла", МетаданныеОбъекта);
	ВозможностьХранитьВерсии = ОбщегоНазначения.ЕстьРеквизитОбъекта("ТекущаяВерсия", МетаданныеОбъекта);
	Если ВозможностьХранитьВерсии И ЗначениеЗаполнено(ФайлИлиВерсияСсылка.ТекущаяВерсия) Тогда
		ВерсияСсылка = ФайлИлиВерсияСсылка.ТекущаяВерсия;
		ДанныеФайла = ДанныеФайла(ФайлИлиВерсияСсылка, ВерсияСсылка);
	ИначеЕсли ЭтоСправочникФайлов Тогда
		ВерсияСсылка = ФайлИлиВерсияСсылка;
		ДанныеФайла = ДанныеФайла(ФайлИлиВерсияСсылка);
	Иначе
		ВерсияСсылка = ФайлИлиВерсияСсылка;
		ДанныеФайла = ДанныеФайла(ФайлИлиВерсияСсылка.Владелец, ВерсияСсылка);
	КонецЕсли;
	
	ДвоичныеДанные = Неопределено;
	
	ТипХраненияФайла = ВерсияСсылка.ТипХраненияФайла;
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ ВерсияСсылка.Том.Пустая() Тогда
			ПолныйПуть = РаботаСФайламиСлужебный.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
			Исключение
				// Запись в журнал регистрации.
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(
					ИнформацияОбОшибке(), ВерсияСсылка.Владелец);
				
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Файлы.Открытие файла'",
					     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Ошибка,
					Метаданные.Справочники.Файлы,
					ВерсияСсылка.Владелец,
					СообщениеОбОшибке);
				
				ВызватьИсключение РаботаСФайламиСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ВерсияСсылка.ПолноеНаименование + "." + ВерсияСсылка.Расширение);
			КонецПопытки;
		КонецЕсли;
	Иначе
		ХранилищеФайла = РаботаСФайлами.ХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
		ДвоичныеДанные = ХранилищеФайла.Получить();
	КонецЕсли;

	ДвоичныеДанныеПодписи = Неопределено;
	Если АдресПодписи <> Неопределено Тогда
		ДвоичныеДанныеПодписи = ПолучитьИзВременногоХранилища(АдресПодписи);
	КонецЕсли;
	
	Если ИдентификаторФормы <> Неопределено Тогда
		ДвоичныеДанные = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
	КонецЕсли;
	
	СтруктураВозврата = Новый Структура("ДанныеФайла, ДвоичныеДанные, ДвоичныеДанныеПодписи",
		ДанныеФайла, ДвоичныеДанные, ДвоичныеДанныеПодписи);
	
	Возврат СтруктураВозврата;
КонецФункции

// Получает все подчиненные файлы.
// Параметры:
//  ВладелецФайла - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   Массив - массив файлов
Функция ПолучитьВсеПодчиненныеФайлы(ВладелецФайла) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Файлы.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.ВладелецФайла = &ВладелецФайла";
	
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Создать папку файлов.
//
// Параметры:
//   Имя - Строка - имя папки
//   Родитель - ОпределяемыйТип.ВладелецПрисоединенныхФайлов - родительская папка.
//   Пользователь - СправочникСсылка.Пользователи - ответственный за папку.
//   ГруппаФайлов - ОпределяемыйТип.ПрисоединенныйФайл - группа (для иерархических справочников файлов).
//
// Возвращаемое значение:
//   СправочникСсылка.ПапкиФайлов.
//
Функция СоздатьПапкуФайлов(Имя, Родитель, Пользователь = Неопределено, ГруппаФайлов = Неопределено) Экспорт
	
	Если ЭтоСправочникФайлы(Родитель) Тогда
		Папка = Справочники.ПапкиФайлов.СоздатьЭлемент();
		Папка.Ответственный = ?(Пользователь <> Неопределено, Пользователь, Пользователи.ТекущийПользователь());
		Папка.Родитель = Родитель;
	Иначе
		Папка = Справочники[РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(Родитель)].СоздатьГруппу();
		Папка.ВладелецФайла = Родитель;
		Папка.Автор = ?(Пользователь <> Неопределено, Пользователь, Пользователи.ТекущийПользователь());
		Папка.Родитель = ГруппаФайлов;
	КонецЕсли;
	Папка.Наименование = Имя;
	Папка.ДатаСоздания = ТекущаяДатаСеанса();
	Папка.Заполнить(Неопределено);
	Папка.Записать();
	Возврат Папка.Ссылка;
	
КонецФункции

// Создает файл в ИБ вместе с версией.
//
// Параметры:
//   Владелец       - СправочникСсылка.ПапкиФайлов, ЛюбаяСсылка - будет установлен в реквизит ВладелецФайла у
//                    созданного файла.
//   СведенияОФайле - Структура - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме "ФайлСВерсией".
//
// Возвращаемое значение:
//    СправочникСсылка.Файлы - созданный файл.
//
Функция СоздатьФайлСВерсией(ВладелецФайла, СведенияОФайле) Экспорт
	
	НачатьТранзакцию();
	Попытка
	
		// Создадим карточку Файла в БД.
		ФайлСсылка = СоздатьФайл(ВладелецФайла, СведенияОФайле);
		Версия = Справочники.ВерсииФайлов.ПустаяСсылка();
		Если СведенияОФайле.ХранитьВерсии Тогда
			// Создадим версию сохраняемого файла для сохранения в карточке Файла.
			Версия = РаботаСФайламиСлужебный.СоздатьВерсию(ФайлСсылка, СведенияОФайле);
			// Подставим ссылку на версию в карточку Файла.
		КонецЕсли;
		РаботаСФайламиСлужебный.ОбновитьВерсиюВФайле(ФайлСсылка, Версия, СведенияОФайле.АдресВременногоХранилищаТекста);
		
		Если СведенияОФайле.Кодировка <> Неопределено Тогда
			ЗаписатьКодировкуВерсииФайла(
				?(Версия = Справочники.ВерсииФайлов.ПустаяСсылка(), ФайлСсылка, Версия), СведенияОФайле.Кодировка);
		КонецЕсли;
		
		ЕстьПравоСохранения = ПравоДоступа("СохранениеДанныхПользователя", Метаданные);
		Если СведенияОФайле.ЗаписатьВИсторию И ЕстьПравоСохранения Тогда
			НавигационнаяСсылкаФайла = ПолучитьНавигационнуюСсылку(ФайлСсылка);
			ИсторияРаботыПользователя.Добавить(НавигационнаяСсылкаФайла);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	РаботаСФайламиПереопределяемый.ПриСозданииФайла(ФайлСсылка);
	
	Возврат ФайлСсылка;
	
КонецФункции

// Освобождает файл.
//
// Параметры:
//   ДанныеФайла - Структура - см. ДанныеФайла.
//   УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы.
//
Процедура ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор = Неопределено) Экспорт
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных = Новый БлокировкаДанных;
		ЭлементБлокировкиДанных = БлокировкаДанных.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ДанныеФайла.Ссылка)).ПолноеИмя());
		ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", ДанныеФайла.Ссылка);
		БлокировкаДанных.Заблокировать();
		
		ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
		
		ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
		ФайлОбъект.Редактирует = Справочники.Пользователи.ПустаяСсылка();
		ФайлОбъект.ДатаЗаема = Дата("00010101000000");
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
		
		РаботаСФайламиПереопределяемый.ПриОсвобожденииФайла(ДанныеФайла, УникальныйИдентификатор);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Функция ОсвободитьФайлы(Знач Файлы) Экспорт
	
	Для Каждого ПрисоединенныйФайл Из Файлы Цикл
		РаботаСФайламиСлужебный.ОсвободитьФайл(ПрисоединенныйФайл);
	КонецЦикла;
	Возврат РаботаСФайламиСлужебный.КоличествоЗанятыхФайлов();
	
КонецФункции

// Занимает файл на редактирование (checkout).
//
// Параметры:
//  ДанныеФайла  - структура с данными файла.
//  СтрокаОшибки - строка, в которой возвращается причина ошибки в случае неуспеха (скажем "Файл занят другим
//                 пользователем").
//  УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция.
//
Функция ЗанятьФайл(ДанныеФайла, СтрокаОшибки = "", УникальныйИдентификатор = Неопределено, Пользователь = Неопределено) Экспорт
	
	СтрокаОшибки = "";
	РаботаСФайламиПереопределяемый.ПриПопыткеЗанятьФайл(ДанныеФайла, СтрокаОшибки);
	Если Не ПустаяСтрока(СтрокаОшибки) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных = Новый БлокировкаДанных;
		ЭлементБлокировкиДанных = БлокировкаДанных.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ДанныеФайла.Ссылка)).ПолноеИмя());
		ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", ДанныеФайла.Ссылка);
		БлокировкаДанных.Заблокировать();
		
		ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
		
		ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
		Если Пользователь = Неопределено Тогда
			ФайлОбъект.Редактирует = Пользователи.АвторизованныйПользователь();
		Иначе
			ФайлОбъект.Редактирует = Пользователь;
		КонецЕсли;
		ФайлОбъект.ДатаЗаема = ТекущаяДатаСеанса();
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
		
		НавигационнаяСсылкаТекущейВерсии = ДанныеФайла.НавигационнаяСсылкаТекущейВерсии;
		РабочийКаталогВладельца = ДанныеФайла.РабочийКаталогВладельца;
		
		ДанныеФайла = ДанныеФайла(ДанныеФайла.Ссылка, ?(ДанныеФайла.Версия = ДанныеФайла.Ссылка, Неопределено, ДанныеФайла.Версия));
		ДанныеФайла.НавигационнаяСсылкаТекущейВерсии = НавигационнаяСсылкаТекущейВерсии;
		ДанныеФайла.РабочийКаталогВладельца = РабочийКаталогВладельца;
		
		РаботаСФайламиПереопределяемый.ПриЗахватеФайла(ДанныеФайла, УникальныйИдентификатор);
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Функция возвращает структуру, содержащую различные сведения о файле и версии.
//
// Параметры:
//  ФайлИлиВерсияСсылка  - СправочникСсылка.Файлы, СправочникСсылка.ВерсииФайлов - файл или версия файла.
//
// Возвращаемое значение:
//   Структура - структура с данными файла.
//
Функция ДанныеФайла(ФайлСсылка, ВерсияСсылка = Неопределено, ИдентификаторФормы = Неопределено) Экспорт
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ФайлСсылка, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ОбновлениеИнформационнойБазы.ПроверитьОбъектОбработан(ФайлСсылка);
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	
	ДанныеФайла = Новый Структура;
	ДанныеФайла.Вставить("Ссылка", ФайлОбъект.Ссылка);
	ДанныеФайла.Вставить("Редактирует", ФайлОбъект.Редактирует);
	ДанныеФайла.Вставить("Владелец", ФайлОбъект.ВладелецФайла);
	
	МетаданныеОбъектаФайла = Метаданные.НайтиПоТипу(ТипЗнч(ФайлСсылка));
	
	Если ОбщегоНазначения.ЕстьРеквизитОбъекта("ТекущаяВерсия", МетаданныеОбъектаФайла) И ЗначениеЗаполнено(ФайлСсылка.ТекущаяВерсия) Тогда
		ТекущаяВерсияФайла = ФайлОбъект.ТекущаяВерсия;
		// Без возможности хранить версии.
	Иначе
		ТекущаяВерсияФайла = ФайлСсылка;
	КонецЕсли;
	
	Если ВерсияСсылка <> Неопределено Тогда
		ДанныеФайла.Вставить("Версия", ВерсияСсылка);
	Иначе
		ДанныеФайла.Вставить("Версия", ТекущаяВерсияФайла);
	КонецЕсли;
	
	ДанныеФайла.Вставить("ТекущаяВерсия", ТекущаяВерсияФайла);
	ДанныеФайла.Вставить("ХранитьВерсии", ФайлОбъект.ХранитьВерсии);
	ДанныеФайла.Вставить("ПометкаУдаления", ФайлОбъект.ПометкаУдаления);
	ДанныеФайла.Вставить("Зашифрован", ФайлОбъект.Зашифрован);
	ДанныеФайла.Вставить("ПодписанЭП", ФайлОбъект.ПодписанЭП);
	ДанныеФайла.Вставить("ДатаЗаема", ФайлОбъект.ДатаЗаема);
	
	Если ВерсияСсылка = Неопределено Тогда
		ДанныеФайла.Вставить("СсылкаНаДвоичныеДанныеФайла",
			ПоместитьВоВременноеХранилище(РаботаСФайлами.ДвоичныеДанныеФайла(ФайлСсылка), ИдентификаторФормы));
		ДанныеФайла.Вставить("НавигационнаяСсылка", ПолучитьНавигационнуюСсылку(ФайлСсылка));
		ДанныеФайла.Вставить("АвторТекущейВерсии", ФайлСсылка.Изменил);
	Иначе
		ДанныеФайла.Вставить("СсылкаНаДвоичныеДанныеФайла",
			ПоместитьВоВременноеХранилище(РаботаСФайлами.ДвоичныеДанныеФайла(ВерсияСсылка), ИдентификаторФормы));
		ДанныеФайла.Вставить("НавигационнаяСсылка", ПолучитьНавигационнуюСсылку(ФайлОбъект.Ссылка));
		ДанныеФайла.Вставить("АвторТекущейВерсии", ВерсияСсылка.Автор);
	КонецЕсли;
	
	Если ДанныеФайла.Зашифрован Тогда
		МассивСертификатовШифрования = СертификатыШифрования(ДанныеФайла.Ссылка);
		ДанныеФайла.Вставить("МассивСертификатовШифрования", МассивСертификатовШифрования);
	КонецЕсли;
	
	ЗаполнитьДополнительныеДанныеФайла(ДанныеФайла, ФайлОбъект, ВерсияСсылка);
	
	Возврат ДанныеФайла;
	
КонецФункции

Процедура ЗаполнитьДополнительныеДанныеФайла(Результат, ПрисоединенныйФайл, ВерсияФайла = Неопределено) Экспорт
	
	СправочникПоддерживаетВозможностьХранитьВерсии = ОбщегоНазначения.ЕстьРеквизитОбъекта("ТекущаяВерсия", Метаданные.НайтиПоТипу(ТипЗнч(ПрисоединенныйФайл)));
	
	Если СправочникПоддерживаетВозможностьХранитьВерсии И ЗначениеЗаполнено(ПрисоединенныйФайл.ТекущаяВерсия) Тогда
		ТекущаяВерсияФайла = ПрисоединенныйФайл.ТекущаяВерсия;
	Иначе
		ТекущаяВерсияФайла = ПрисоединенныйФайл.Ссылка;
	КонецЕсли;
	
	Результат.Вставить("ТекущаяВерсия", ТекущаяВерсияФайла);
	
	Если ВерсияФайла <> Неопределено Тогда
		Результат.Вставить("Версия", ВерсияФайла);
	ИначеЕсли СправочникПоддерживаетВозможностьХранитьВерсии И ЗначениеЗаполнено(ПрисоединенныйФайл.ТекущаяВерсия) Тогда
		Результат.Вставить("Версия", ПрисоединенныйФайл.ТекущаяВерсия);
	Иначе
		Результат.Вставить("Версия", ПрисоединенныйФайл.Ссылка);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ВерсияФайла) Тогда
		ВерсияОбъект = ВерсияФайла.ПолучитьОбъект();
		Результат.Вставить("Наименование",                 ВерсияОбъект.Наименование);
		Результат.Вставить("Расширение",                   ВерсияОбъект.Расширение);
		Результат.Вставить("Размер",                       ВерсияОбъект.Размер);
		Результат.Вставить("НомерВерсии",                  ВерсияОбъект.Размер);
		Результат.Вставить("ДатаМодификацииУниверсальная", ВерсияОбъект.ДатаМодификацииУниверсальная);
		Результат.Вставить("Том",                          ВерсияОбъект.Том);
		Результат.Вставить("Автор",                        ВерсияОбъект.Автор);
		Результат.Вставить("СтатусИзвлеченияТекста",       ВерсияОбъект.СтатусИзвлеченияТекста);
		Результат.Вставить("ПолноеНаименованиеВерсии",     СокрЛП(ВерсияОбъект.ПолноеНаименование));
		ТекущаяВерсияФайла = ВерсияФайла;
	Иначе
		Результат.Вставить("Наименование",                 ПрисоединенныйФайл.Наименование);
		Результат.Вставить("Расширение",                   ПрисоединенныйФайл.Расширение);
		Результат.Вставить("Размер",                       ПрисоединенныйФайл.Размер);
		Результат.Вставить("НомерВерсии",                  0);
		Результат.Вставить("ДатаМодификацииУниверсальная", ПрисоединенныйФайл.ДатаМодификацииУниверсальная);
		Результат.Вставить("Том",                          ПрисоединенныйФайл.Том);
		Результат.Вставить("Автор",                        ПрисоединенныйФайл.Автор);
		Результат.Вставить("СтатусИзвлеченияТекста",       ПрисоединенныйФайл.СтатусИзвлеченияТекста);
		Результат.Вставить("ПолноеНаименованиеВерсии",     СокрЛП(ПрисоединенныйФайл.Наименование));
		ТекущаяВерсияФайла = Результат.Версия;
	КонецЕсли;
	
	СтруктураКлюча = Новый Структура("Файл", ТекущаяВерсияФайла);
	КлючЗаписи = РегистрыСведений.ДвоичныеДанныеФайлов.СоздатьКлючЗаписи(СтруктураКлюча);
	НавигационнаяСсылкаТекущейВерсии = ПолучитьНавигационнуюСсылку(КлючЗаписи, "ДвоичныеДанныеФайла");
	Результат.Вставить("НавигационнаяСсылкаТекущейВерсии", НавигационнаяСсылкаТекущейВерсии);
	
	КодировкаТекущейВерсии = ПолучитьКодировкуВерсииФайла(ТекущаяВерсияФайла);
	Результат.Вставить("КодировкаТекущейВерсии", КодировкаТекущейВерсии);
	ТекущийПользователь = Пользователи.АвторизованныйПользователь();
	НаЧтение = Результат.Редактирует <> ТекущийПользователь;
	Результат.Вставить("НаЧтение", НаЧтение);
	
	ВРабочемКаталогеНаЧтение = Истина;
	ВРабочемКаталогеВладельца = Ложь;
	ИмяКаталога = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("ЛокальныйКэшФайлов", "ПутьКЛокальномуКэшуФайлов");
	Если ИмяКаталога = Неопределено Тогда
		ИмяКаталога = "";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекущаяВерсияФайла) Тогда
		ПолноеИмяФайлаВРабочемКаталоге = ПолучитьПолноеИмяФайлаИзРегистра(ТекущаяВерсияФайла, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
	
		Результат.Вставить("ПолноеИмяФайлаВРабочемКаталоге", ПолноеИмяФайлаВРабочемКаталоге);
	КонецЕсли;
	Результат.Вставить("ВРабочемКаталогеНаЧтение", ВРабочемКаталогеНаЧтение);
	Результат.Вставить("РабочийКаталогВладельца", "");
	
	РедактируетТекущийПользователь = (Результат.Редактирует = ТекущийПользователь);
	Результат.Вставить("ФайлРедактируетТекущийПользователь", РедактируетТекущийПользователь);
	
	СтатусИзвлеченияТекстаСтрока = "НеИзвлечен";
	Если Результат.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен Тогда
		СтатусИзвлеченияТекстаСтрока = "НеИзвлечен";
	ИначеЕсли Результат.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен Тогда
		СтатусИзвлеченияТекстаСтрока = "Извлечен";
	ИначеЕсли Результат.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось Тогда
		СтатусИзвлеченияТекстаСтрока = "ИзвлечьНеУдалось";
	КонецЕсли;
	Результат.Вставить("СтатусИзвлеченияТекста", СтатусИзвлеченияТекстаСтрока);
	
	ПапкаДляСохранитьКак = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПрограммы", "ПапкаДляСохранитьКак");
	Результат.Вставить("ПапкаДляСохранитьКак", ПапкаДляСохранитьКак);
	
КонецПроцедуры

Функция ПолучитьДанныеФайла(Знач ПрисоединенныйФайл,
                            Знач ИдентификаторФормы = Неопределено,
                            Знач ПолучатьСсылкуНаДвоичныеДанные = Истина,
                            Знач ДляРедактирования = Ложь) Экспорт
	
	Возврат РаботаСФайлами.ДанныеФайла(ПрисоединенныйФайл, 
                    ИдентификаторФормы,
                    ПолучатьСсылкуНаДвоичныеДанные,
                    ДляРедактирования);
КонецФункции

Функция ДанныеФайлаДляПечати(Знач ПрисоединенныйФайл) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(ПрисоединенныйФайл);
	Расширение = НРег(ДанныеФайла.Расширение);
	Если Расширение = "mxl" Тогда
		ДвоичныеДанныеФайла = ПолучитьИзВременногоХранилища(ДанныеФайла.СсылкаНаДвоичныеДанныеФайла);
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
		ДвоичныеДанныеФайла.Записать(ИмяВременногоФайла);
		ТабличныйДокумент = Новый ТабличныйДокумент;
		ТабличныйДокумент.Прочитать(ИмяВременногоФайла);
		УстановленБезопасныйРежим = БезопасныйРежим() <> Ложь;
		
		Если ТипЗнч(УстановленБезопасныйРежим) = Тип("Строка") Тогда
			УстановленБезопасныйРежим = Истина;
		КонецЕсли;
	
		Если Не УстановленБезопасныйРежим Тогда
			УдалитьФайлы(ИмяВременногоФайла);
		КонецЕсли;
		ДанныеФайла.Вставить("ТабличныйДокумент", ТабличныйДокумент);
	КонецЕсли;
	
	Возврат ДанныеФайла;
	
КонецФункции

// Функция возвращает структуру, содержащую различные сведения о Файле и версии.
Функция ДанныеФайлаДляОткрытия(ФайлСсылка, ВерсияСсылка, ИдентификаторФормы = Неопределено,
	РабочийКаталогВладельца = Неопределено, ПредыдущийАдресФайла = Неопределено) Экспорт
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ФайлСсылка, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПредыдущийАдресФайла <> Неопределено Тогда
		Если НЕ ПустаяСтрока(ПредыдущийАдресФайла) И ЭтоАдресВременногоХранилища(ПредыдущийАдресФайла) Тогда
			УдалитьИзВременногоХранилища(ПредыдущийАдресФайла);
		КонецЕсли;
	КонецЕсли;
	
	ФайлСсылка = ФайлСсылка;
	ВерсияСсылка = ВерсияСсылка;
	Если Не ЗначениеЗаполнено(ВерсияСсылка) 
		И ОбщегоНазначения.ЕстьРеквизитОбъекта("ТекущаяВерсия", Метаданные.НайтиПоТипу(ТипЗнч(ФайлСсылка)))
		И ЗначениеЗаполнено(ФайлСсылка.ТекущаяВерсия) Тогда
		
		ВерсияСсылка = ФайлСсылка.ТекущаяВерсия;
		
	КонецЕсли;
	ДанныеФайла = ДанныеФайла(ФайлСсылка, ВерсияСсылка, ИдентификаторФормы);
	
	Если РабочийКаталогВладельца = Неопределено Тогда
		РабочийКаталогВладельца = РабочийКаталогПапки(ДанныеФайла.Владелец);
	КонецЕсли;
	ДанныеФайла.Вставить("РабочийКаталогВладельца", РабочийКаталогВладельца);
	
	Если ДанныеФайла.РабочийКаталогВладельца <> "" Тогда
		ИмяФайла = ОбщегоНазначенияКлиентСервер.ПолучитьИмяСРасширением(
			ДанныеФайла.ПолноеНаименованиеВерсии, ДанныеФайла.Расширение);
		ПолноеИмяФайлаВРабочемКаталоге = РабочийКаталогВладельца + ИмяФайла;
		ДанныеФайла.Вставить("ПолноеИмяФайлаВРабочемКаталоге", ПолноеИмяФайлаВРабочемКаталоге);
	КонецЕсли;
	
	ТипХраненияФайла = ДанныеФайла.Версия.ТипХраненияФайла;
	
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ДанныеФайла.Версия <> Неопределено Тогда
		
		УстановитьПривилегированныйРежим(Истина);
		
		ДанныеФайлаТом = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
		ДанныеФайлаПутьКФайлу = "";
		ДанныеФайлаТом = ДанныеФайла.Версия.Том;
		ДанныеФайлаПутьКФайлу = ДанныеФайла.Версия.ПутьКФайлу;
		
		Если НЕ ДанныеФайлаТом.Пустая() Тогда
			ПолныйПуть = РаботаСФайламиСлужебный.ПолныйПутьТома(ДанныеФайлаТом) + ДанныеФайлаПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
				// Работаем только с текущей версией - для не-текущей ссылку получаем в ПолучитьНавигационнуюСсылкуДляОткрытия.
				ДанныеФайла.НавигационнаяСсылкаТекущейВерсии = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
			Исключение
				// Запись в журнал регистрации.
				СсылкаНаФайл = ?(ФайлСсылка <> Неопределено, ФайлСсылка, ВерсияСсылка);
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(
					ИнформацияОбОшибке(), СсылкаНаФайл);
				
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Файлы.Открытие файла'",
					     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Ошибка,
					Метаданные.Справочники.Файлы,
					ФайлСсылка,
					СообщениеОбОшибке);
				
				Если ЭтоСправочникФайлы(ДанныеФайла.Владелец) Тогда
					ПредставлениеВладельца = ПолныйПутьПапки(ДанныеФайла.Владелец);
				Иначе
					ПредставлениеВладельца = ДанныеФайла.Владелец;
				КонецЕсли;
				ПредставлениеВладельцаФайла = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Присоединен к %1 : %2'"),
					Строка(ТипЗнч(ДанныеФайла.Владелец)),
					ПредставлениеВладельца);
				
				ВызватьИсключение РаботаСФайламиСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ДанныеФайла.ПолноеНаименованиеВерсии + "." + ДанныеФайла.Расширение,
					,
					ПредставлениеВладельцаФайла);
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	ПредыдущийАдресФайла = ДанныеФайла.НавигационнаяСсылкаТекущейВерсии;
	
	Возврат ДанныеФайла;
	
КонецФункции

// Возвращает текст запроса для получения файлов у которых не извлечен текст.
//
// Параметры:
//  ПолучитьВсеФайлы - Булево - начальное значение Ложь. Позволяет отключить выборку
//                     файлов по частям, если передать Истина.
//
// Возвращаемое значение:
//  Строка - текст запроса.
//
Функция ТекстЗапросаДляИзвлеченияТекста(ПолучитьВсеФайлы = Ложь, ДополнительныеПоля = Ложь) Экспорт
	
	// Текст запроса формируется по всем справочникам присоединенных файлов.
	ТекстЗапроса = "";
	
	ТипыФайлов = Метаданные.ОпределяемыеТипы.ПрисоединенныйФайл.Тип.Типы();
	
	ВсеИменаСправочников = Новый Массив;
	
	Для Каждого Тип Из ТипыФайлов Цикл
		МетаданныеСправочникаФайлов = Метаданные.НайтиПоТипу(Тип);
		НеИспользоватьПолнотекстовыйПоиск = Метаданные.СвойстваОбъектов.ИспользованиеПолнотекстовогоПоиска.НеИспользовать;
		Если МетаданныеСправочникаФайлов.ПолнотекстовыйПоиск = НеИспользоватьПолнотекстовыйПоиск Тогда
			Продолжить;
		КонецЕсли;
		ВсеИменаСправочников.Добавить(МетаданныеСправочникаФайлов.Имя);
	КонецЦикла;
	
	ЧислоФайловВВыборке = Цел(100 / ВсеИменаСправочников.Количество());
	ЧислоФайловВВыборке = ?(ЧислоФайловВВыборке < 10, 10, ЧислоФайловВВыборке);
	
	Для каждого ИмяСправочника Из ВсеИменаСправочников Цикл
	
		Если НЕ ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + "
				|
				|ОБЪЕДИНИТЬ ВСЕ
				|
				|";
		КонецЕсли;
		
		ТекстЗапроса = ТекстЗапроса + ТекстЗапросаДляФайловСНеизвлеченнымТекстом(ИмяСправочника,
			ЧислоФайловВВыборке, ПолучитьВсеФайлы, ДополнительныеПоля);
		КонецЦикла;
		
	Возврат ТекстЗапроса;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЭтоСправочникФайлы(ВладелецФайлов) Экспорт
	
	Возврат РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(ВладелецФайлов) = "Файлы";
	
КонецФункции

Функция ИмяСправочникаХраненияФайлов(ВладелецФайлов) Экспорт
	
	Возврат РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(ВладелецФайлов);
	
КонецФункции

// Создает файл в ИБ.
//
// Параметры:
//   Владелец       - СправочникСсылка.ПапкиФайлов, ЛюбаяСсылка - будет установлен в реквизит ВладелецФайла у
//                    созданного файла.
//   СведенияОФайле - Структура - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме "Файл".
//
// Возвращаемое значение:
//    СправочникСсылка.Файлы - созданный файл.
//
Функция СоздатьФайл(Знач Владелец, Знач СведенияОФайле)
	
	Файл = Справочники[СведенияОФайле.ИмяСправочникаХранилищаФайлов].СоздатьЭлемент();
	Файл.ВладелецФайла = Владелец;
	Файл.Наименование = СведенияОФайле.ИмяБезРасширения;
	Файл.Автор = ?(СведенияОФайле.Автор <> Неопределено, СведенияОФайле.Автор, Пользователи.ТекущийПользователь());
	Файл.ДатаСоздания = ТекущаяДатаСеанса();
	Файл.Описание = СведенияОФайле.Комментарий;
	Файл.ИндексКартинки = РаботаСФайламиСлужебныйКлиентСервер.ПолучитьИндексПиктограммыФайла(Неопределено);
	Файл.ХранитьВерсии = СведенияОФайле.ХранитьВерсии;
	
	Если ТипЗнч(СведенияОФайле.АдресВременногоХранилищаТекста) = Тип("ХранилищеЗначения") Тогда
		// При создании Файла из шаблона хранилище значения копируется напрямую.
		Файл.ТекстХранилище = СведенияОФайле.АдресВременногоХранилищаТекста;
	ИначеЕсли Не ПустаяСтрока(СведенияОФайле.АдресВременногоХранилищаТекста) Тогда
		Текст = РаботаСФайламиСлужебный.ПолучитьСтрокуИзВременногоХранилища(СведенияОФайле.АдресВременногоХранилищаТекста);
		Файл.ТекстХранилище = Новый ХранилищеЗначения(Текст);
	КонецЕсли;
	
	Файл.Заполнить(Неопределено);
	Файл.Записать();
	Возврат Файл.Ссылка;
	
КонецФункции

// Обновляет или создает версию Файла и возвращает ссылку на обновленную версию (или Ложь, если файл бинарно не
// изменен).
//
// Параметры:
//   ФайлСсылка     - СправочникСсылка.Файлы        - файл, для которого создается новая версия.
//   СведенияОФайле - Структура                     - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме
//                                                    "ФайлСВерсией".
//   ВерсияСсылка   - СправочникСсылка.ВерсииФайлов - версия файла, которую надо обновить.
//   УникальныйИдентификаторФормы                   - УникальныйИдентификатор - уникальный идентификатор формы, 
//                                                    в контексте которой выполняется операция.
//
// Возвращаемое значение:
//   СправочникСсылка.ВерсииФайлов - созданная или измененная версия; Неопределено, если файл бинарно не был изменен.
//
Функция ОбновитьОбъектФайла(ФайлСсылка,
	СведенияОФайле,
	ВерсияСсылка = Неопределено,
	УникальныйИдентификаторФормы = Неопределено,
	Пользователь = Неопределено)
	
	ЕстьПравоСохранения = ПравоДоступа("СохранениеДанныхПользователя", Метаданные);
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ФайлСсылка, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВремяИзмененияУниверсальное = СведенияОФайле.ВремяИзмененияУниверсальное;
	Если НЕ ЗначениеЗаполнено(ВремяИзмененияУниверсальное)
		ИЛИ ВремяИзмененияУниверсальное > ТекущаяУниверсальнаяДата() Тогда
		ВремяИзмененияУниверсальное = ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
	ВремяИзменения = СведенияОФайле.ВремяИзменения;
	Если НЕ ЗначениеЗаполнено(ВремяИзменения)
		ИЛИ УниверсальноеВремя(ВремяИзменения) > ВремяИзмененияУниверсальное Тогда
		ВремяИзменения = ТекущаяДатаСеанса();
	КонецЕсли;
	
	РаботаСФайламиСлужебныйКлиентСервер.ПроверитьРасширениеФайлаДляЗагрузки(СведенияОФайле.РасширениеБезТочки);
	
	ТекущаяВерсияРазмер = 0;
	ДвоичныеДанные = Неопределено;
	ТекущаяВерсияТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
	ТекущаяВерсияТом = Неопределено;
	ТекущаяВерсияПутьКФайлу = Неопределено;
	
	СправочникПоддерживаетВозможностьХранитьВерсии = ОбщегоНазначения.ЕстьРеквизитОбъекта("ТекущаяВерсия", Метаданные.НайтиПоТипу(ТипЗнч(ФайлСсылка)));
	
	ВерсияСсылкаДляСравненияРазмера = ВерсияСсылка;
	Если ВерсияСсылка <> Неопределено Тогда
		ВерсияСсылкаДляСравненияРазмера = ВерсияСсылка;
	ИначеЕсли СправочникПоддерживаетВозможностьХранитьВерсии И ЗначениеЗаполнено(ФайлСсылка.ТекущаяВерсия) Тогда
		ВерсияСсылкаДляСравненияРазмера = ФайлСсылка.ТекущаяВерсия;
	Иначе
		ВерсияСсылкаДляСравненияРазмера = ФайлСсылка;
	КонецЕсли;
	
	КодировкаПредВерсии = ПолучитьКодировкуВерсииФайла(ВерсияСсылкаДляСравненияРазмера);
	
	СтруктураРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ВерсияСсылкаДляСравненияРазмера, 
		"Размер, ТипХраненияФайла, Том, ПутьКФайлу");
	ТекущаяВерсияРазмер = СтруктураРеквизитов.Размер;
	ТекущаяВерсияТипХраненияФайла = СтруктураРеквизитов.ТипХраненияФайла;
	ТекущаяВерсияТом = СтруктураРеквизитов.Том;
	ТекущаяВерсияПутьКФайлу = СтруктураРеквизитов.ПутьКФайлу;
	
	ХранилищеФайла = Неопределено;
	Если СведенияОФайле.Размер = ТекущаяВерсияРазмер Тогда
		ДвоичныеДанныеПредыдущейВерсии = Неопределено;
		
		Если ТекущаяВерсияТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			Если НЕ ТекущаяВерсияТом.Пустая() Тогда
				ПолныйПуть = РаботаСФайламиСлужебный.ПолныйПутьТома(ТекущаяВерсияТом) + ТекущаяВерсияПутьКФайлу; 
				ДвоичныеДанныеПредыдущейВерсии = Новый ДвоичныеДанные(ПолныйПуть);
			КонецЕсли;
		Иначе
			ХранилищеФайла = РаботаСФайлами.ХранилищеФайлаИзИнформационнойБазы(ВерсияСсылкаДляСравненияРазмера);
			ДвоичныеДанныеПредыдущейВерсии = ХранилищеФайла.Получить();
		КонецЕсли;
		
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(СведенияОФайле.АдресВременногоХранилищаФайла);
		
		Если ДвоичныеДанныеПредыдущейВерсии = ДвоичныеДанные Тогда
			Возврат Неопределено; // Файл бинарно не изменен - вернем Ложь.
		КонецЕсли;
	КонецЕсли;
	
	СтарыйТипХранения = Неопределено;
	ВерсияЗаблокирована = Ложь;
	Версия = Неопределено;
	
	Если ВерсияСсылка = Неопределено Тогда
		Версия = ФайлСсылка.ПолучитьОбъект();
	КонецЕсли;
	
	ЗаблокироватьДанныеДляРедактирования(Версия.Ссылка, , УникальныйИдентификаторФормы);
	ВерсияЗаблокирована = Истина;
	
	// Удалим файл с диска - мы заместим его новым.
	Если Версия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ Версия.Том.Пустая() Тогда
			ПолныйПуть = РаботаСФайламиСлужебный.ПолныйПутьТома(Версия.Том) + Версия.ПутьКФайлу; 
			ФайлНаДиске = Новый Файл(ПолныйПуть);
			Если ФайлНаДиске.Существует() Тогда
				ФайлНаДиске.УстановитьТолькоЧтение(Ложь);
				УдалитьФайлы(ПолныйПуть);
			КонецЕсли;
			ПутьСПодкаталогом = ФайлНаДиске.Путь;
			МассивФайловВКаталоге = НайтиФайлы(ПутьСПодкаталогом, "*.*");
			Если МассивФайловВКаталоге.Количество() = 0 Тогда
				УдалитьФайлы(ПутьСПодкаталогом);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Пользователь = Неопределено Тогда
		Версия.Изменил = Пользователи.ТекущийПользователь();
	Иначе
		Версия.Изменил = Пользователь;
	КонецЕсли;
	Версия.ДатаМодификацииУниверсальная = ВремяИзмененияУниверсальное;
	Версия.Размер                       = СведенияОФайле.Размер;
	Версия.Наименование                 = СведенияОФайле.ИмяБезРасширения;
	Версия.Описание                     = СведенияОФайле.Комментарий;
	Версия.Расширение                   = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(СведенияОФайле.РасширениеБезТочки);
	
	ТипХраненияФайлов = РаботаСФайламиСлужебный.ТипХраненияФайлов();
	Версия.ТипХраненияФайла = ТипХраненияФайлов;
	
	Если ДвоичныеДанные = Неопределено Тогда
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(СведенияОФайле.АдресВременногоХранилищаФайла);
	КонецЕсли;
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		
		ХранилищеФайла = Новый ХранилищеЗначения(ДвоичныеДанные);
			
		Если Версия.Размер = 0 Тогда
			ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
			Версия.Размер = ДвоичныеДанныеФайла.Размер();
			
			РаботаСФайламиСлужебныйКлиентСервер.ПроверитьРазмерФайлаДляЗагрузки(Версия);
		КонецЕсли;
		
		// очистим поля
		Версия.ПутьКФайлу = "";
		Версия.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
	Иначе // хранение на диске
		
		Если Версия.Размер = 0 Тогда
			Версия.Размер = ДвоичныеДанные.Размер();
			РаботаСФайламиСлужебныйКлиентСервер.ПроверитьРазмерФайлаДляЗагрузки(Версия);
		КонецЕсли;
		
		ФайлЗашифрован = Ложь;
		Если СведенияОФайле.Зашифрован <> Неопределено Тогда
			ФайлЗашифрован = СведенияОФайле.Зашифрован;
		КонецЕсли;
		
		Сведения = РаботаСФайламиСлужебный.ДобавитьФайлВТом(ДвоичныеДанные,
			ВремяИзмененияУниверсальное, СведенияОФайле.ИмяБезРасширения, Версия.Расширение,
			"", ФайлЗашифрован); 
		Версия.Том = Сведения.Том;
		Версия.ПутьКФайлу = Сведения.ПутьКФайлу;
		ХранилищеФайла = Новый ХранилищеЗначения(Неопределено); // очистим ХранилищеЗначения
		
	КонецЕсли;
	
	Если СведенияОФайле.АдресВременногоХранилищаТекста <> Неопределено Тогда
		Если РаботаСФайламиСлужебный.ИзвлекатьТекстыФайловНаСервере() Тогда
			Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
		Иначе
			Текст = РаботаСФайламиСлужебный.ПолучитьСтрокуИзВременногоХранилища(СведенияОФайле.АдресВременногоХранилищаТекста);
			Версия.ТекстХранилище = Новый ХранилищеЗначения(Текст);
			Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		КонецЕсли;
	Иначе
		Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	КонецЕсли;
	
	Если СведенияОФайле.НовыйСтатусИзвлеченияТекста <> Неопределено Тогда
		Версия.СтатусИзвлеченияТекста = СведенияОФайле.НовыйСтатусИзвлеченияТекста;
	КонецЕсли;

	Если Версия.Размер = 0 Тогда
		Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
			Версия.Размер = ДвоичныеДанныеФайла.Размер();
		КонецЕсли;
	КонецЕсли;
	
	Версия.Заполнить(Неопределено);
	Версия.Записать();
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		ЗаписатьФайлВИнформационнуюБазу(Версия.Ссылка, ХранилищеФайла);
	КонецЕсли;
	
	Если ВерсияЗаблокирована Тогда
		РазблокироватьДанныеДляРедактирования(Версия.Ссылка, УникальныйИдентификаторФормы);
	КонецЕсли;
	
	ЗаписатьКодировкуВерсииФайла(Версия.Ссылка, КодировкаПредВерсии);

	Если ЕстьПравоСохранения Тогда
		НавигационнаяСсылкаФайла = ПолучитьНавигационнуюСсылку(ФайлСсылка);
		ИсторияРаботыПользователя.Добавить(НавигационнаяСсылкаФайла);
	КонецЕсли;
	
	Возврат Версия.Ссылка;
	
КонецФункции

// Обновляет или создает версию файла и снимает блокировку. 
//
// Параметры:
//   ДанныеФайла                  - Структура - структура с данными файла.
//   СведенияОФайле               - Структура - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме "ФайлСВерсией".
//   НеМенятьЗаписьВРабочемКаталоге - Булево  - не менять запись в регистре сведений ФайлыВРабочемКаталоге.
//   ПолныйПутьКФайлу             - Строка    - указывается, если НеМенятьЗаписьВРабочемКаталоге = Ложь.
//   РабочийКаталогПользователя   - Строка    - указывается, если НеМенятьЗаписьВРабочемКаталоге = Ложь.
//   УникальныйИдентификаторФормы - УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Булево - Истина, если создание версии выполнено (и файл бинарно изменен).
//
Функция СохранитьИзмененияИОсвободитьФайл(ДанныеФайла, СведенияОФайле,
	НеМенятьЗаписьВРабочемКаталоге, ПолныйПутьКФайлу, РабочийКаталогПользователя, 
	УникальныйИдентификаторФормы = Неопределено) Экспорт
	
	ДанныеФайлаТекущие = ДанныеФайла(ДанныеФайла.Ссылка);
	Если Не ДанныеФайлаТекущие.ФайлРедактируетТекущийПользователь И НЕ ФайлСинхронизируетсяОблачнымСервисом(ДанныеФайла.Ссылка) Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;
	
	ВерсияНеСоздана = Ложь;
	
	НачатьТранзакцию();
	Попытка
		ПредыдущаяВерсия = ДанныеФайла.ТекущаяВерсия;
		СведенияОФайле.Зашифрован = ДанныеФайла.Зашифрован;
		
		Если ТипЗнч(ДанныеФайла.Ссылка) = Тип("СправочникСсылка.Файлы") Тогда
			НоваяВерсия = РаботаСФайламиСлужебный.ОбновитьВерсиюФайла(ДанныеФайла.Ссылка, СведенияОФайле,, УникальныйИдентификаторФормы);
		Иначе
			НоваяВерсия = ОбновитьОбъектФайла(ДанныеФайла.Ссылка, СведенияОФайле,, УникальныйИдентификаторФормы);
		КонецЕсли;
		
		Если НоваяВерсия <> Неопределено Тогда
			Если СведенияОФайле.ХранитьВерсии Тогда
				РаботаСФайламиСлужебный.ОбновитьВерсиюВФайле(ДанныеФайла.Ссылка, НоваяВерсия, СведенияОФайле.АдресВременногоХранилищаТекста, УникальныйИдентификаторФормы);
			Иначе
				ОбновитьТекстВФайле(ДанныеФайла.Ссылка, СведенияОФайле.АдресВременногоХранилищаТекста, УникальныйИдентификаторФормы);
			КонецЕсли;
			ДанныеФайла.ТекущаяВерсия = НоваяВерсия;
		КонецЕсли;
			
		ОсвободитьФайл(ДанныеФайла, УникальныйИдентификаторФормы);
		
		Если СведенияОФайле.Кодировка <> Неопределено Тогда
			Если Не ЗначениеЗаполнено(ПолучитьКодировкуВерсииФайла(ДанныеФайла.ТекущаяВерсия)) Тогда
				ЗаписатьКодировкуВерсииФайла(ДанныеФайла.ТекущаяВерсия, СведенияОФайле.Кодировка);
			КонецЕсли;
		КонецЕсли;
		
		Если НоваяВерсия <> Неопределено И НЕ ОбщегоНазначенияКлиентСервер.ЭтоВебКлиент() И Не НеМенятьЗаписьВРабочемКаталоге Тогда
			УдалитьВерсиюИЗанестиИнформациюФайлаВРегистр(ПредыдущаяВерсия, НоваяВерсия,
				ПолныйПутьКФайлу, РабочийКаталогПользователя, ДанныеФайла.РабочийКаталогВладельца <> "");
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат НоваяВерсия <> Неопределено;
	
КонецФункции

// Получает данные файла, затем обновляет или создает версию Файла и снимает блокировку.
// Нужно для случаев, когда на клиенте нет ДанныеФайла (из соображений экономии вызовов клиент-сервер).
//
// Параметры:
//   ФайлСсылка       - СправочникСсылка.Файлы - файл, в котором обновляется версия.
//   СведенияОФайле   - Структура - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме "ФайлСВерсией".
//   ПолныйПутьКФайлу             - Строка
//   РабочийКаталогПользователя   - Строка
//   УникальныйИдентификаторФормы - УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Структура - со свойствами:
//     * Успешно     - Булево    - Истина, если создание версии выполнено (и файл бинарно изменен).
//     * ДанныеФайла - Структура - структура с данными файла.
//
Функция СохранитьИзмененияИОсвободитьФайлПоСсылке(ФайлСсылка, СведенияОФайле, 
	ПолныйПутьКФайлу, РабочийКаталогПользователя, УникальныйИдентификаторФормы = Неопределено) Экспорт
	
	ДанныеФайла = ДанныеФайла(ФайлСсылка);
	ВерсияСоздана = СохранитьИзмененияИОсвободитьФайл(ДанныеФайла, СведенияОФайле, Ложь, ПолныйПутьКФайлу, РабочийКаталогПользователя,
		УникальныйИдентификаторФормы);
	Возврат Новый Структура("Успешно,ДанныеФайла", ВерсияСоздана, ДанныеФайла);
	
КонецФункции

// Предназначена для записи изменений файла без его освобождения.
//
// Параметры:
//   ДанныеФайла                  - Структура - структура с данными файла.
//   СведенияОФайле               - Структура - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме "ФайлСВерсией".
//   НеМенятьЗаписьВРабочемКаталоге - Булево  - не менять запись в регистре сведений ФайлыВРабочемКаталоге.
//   ОтносительныйПутьКФайлу      - Строка    - относительный путь без пути рабочего каталога, например
//                                              "А1/Приказ.doc"; указывается, если НеМенятьЗаписьВРабочемКаталоге =
//                                              Ложь.
//   ПолныйПутьКФайлу             - Строка    - путь на клиенте в рабочем каталоге; указывается, если
//                                              НеМенятьЗаписьВРабочемКаталоге = Ложь.
//   ВРабочемКаталогеВладельца    - Булево    - файл находится в рабочем каталоге владельца.
//   УникальныйИдентификаторФормы - УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Булево  - Истина, если создание версии выполнено (и файл бинарно изменен).
//
Функция СохранитьИзмененияФайла(ФайлСсылка, СведенияОФайле, 
	НеМенятьЗаписьВРабочемКаталоге, ОтносительныйПутьКФайлу, ПолныйПутьКФайлу, ВРабочемКаталогеВладельца,
	УникальныйИдентификаторФормы = Неопределено) Экспорт
	
	ДанныеФайлаТекущие = ДанныеФайла(ФайлСсылка);
	Если Не ДанныеФайлаТекущие.ФайлРедактируетТекущийПользователь И НЕ ФайлСинхронизируетсяОблачнымСервисом(ФайлСсылка) Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;
	
	ВерсияНеСоздана = Ложь;
	ТекущаяВерсия = ДанныеФайлаТекущие.ТекущаяВерсия;
	
	НачатьТранзакцию();
	Попытка
		
		СтараяВерсия = ?(СведенияОФайле.ХранитьВерсии, ФайлСсылка.ТекущаяВерсия, ФайлСсылка);
		СведенияОФайле.Зашифрован = ДанныеФайлаТекущие.Зашифрован;
		
		Если ТипЗнч(ФайлСсылка.Ссылка) = Тип("СправочникСсылка.Файлы") Тогда
			НоваяВерсия = РаботаСФайламиСлужебный.ОбновитьВерсиюФайла(ФайлСсылка.Ссылка, СведенияОФайле,, УникальныйИдентификаторФормы, СведенияОФайле.НоваяВерсияАвтор);
		Иначе
			НоваяВерсия = ОбновитьОбъектФайла(ФайлСсылка.Ссылка, СведенияОФайле,, УникальныйИдентификаторФормы);
		КонецЕсли;
		
		Если НоваяВерсия <> Неопределено Тогда
			ТекущаяВерсия = НоваяВерсия;
			Если СведенияОФайле.ХранитьВерсии Тогда
				РаботаСФайламиСлужебный.ОбновитьВерсиюВФайле(ФайлСсылка, НоваяВерсия, СведенияОФайле.АдресВременногоХранилищаТекста, УникальныйИдентификаторФормы);
				
				Если НЕ ОбщегоНазначенияКлиентСервер.ЭтоВебКлиент() И Не НеМенятьЗаписьВРабочемКаталоге Тогда
					УдалитьИзРегистра(СтараяВерсия);
					ЗаписатьПолноеИмяФайлаВРегистр(НоваяВерсия, ОтносительныйПутьКФайлу, Ложь, ВРабочемКаталогеВладельца);
				КонецЕсли;
				
			Иначе
				ОбновитьТекстВФайле(ФайлСсылка, СведенияОФайле.АдресВременногоХранилищаТекста, УникальныйИдентификаторФормы);
			КонецЕсли;
			
		КонецЕсли;
		
		Если СведенияОФайле.Кодировка <> Неопределено Тогда
			Если Не ЗначениеЗаполнено(ПолучитьКодировкуВерсииФайла(ТекущаяВерсия)) Тогда
				ЗаписатьКодировкуВерсииФайла(ТекущаяВерсия, СведенияОФайле.Кодировка);
			КонецЕсли;
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат НоваяВерсия <> Неопределено;
	
КонецФункции

// Обновляет текстовую порцию из файла в карточке файла.
//
// Параметры:
// ФайлСсылка - СправочникСсылка.Файлы - Файл, в котором создается версия.
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с
//                                           файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные
//                                           данные с файлом текста.
//  УникальныйИдентификатор - уникальный идентификатор формы.
//
Процедура ОбновитьТекстВФайле(ФайлСсылка,
                              Знач АдресВременногоХранилищаТекста,
                              УникальныйИдентификатор = Неопределено)
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных = Новый БлокировкаДанных;
		ЭлементБлокировкиДанных = БлокировкаДанных.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ФайлСсылка)).ПолноеИмя());
		ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", ФайлСсылка);
		БлокировкаДанных.Заблокировать(); 
		
		ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
		
		Текст = РаботаСФайламиСлужебный.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
		
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Создает новый файл по аналогии с указанным и возвращает ссылку на него.
// Параметры:
//  ИсходныйФайл  - СправочникСсылка.Файлы - существующий файл.
//  ВладелецНовогоФайла - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   СправочникСсылка.Файлы - новый файл.
//
Функция СкопироватьФайл(ИсходныйФайл, ВладелецНовогоФайла)
	
	Если ИсходныйФайл = Неопределено Или ИсходныйФайл.Пустая() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(ИсходныйФайл);
	НовыйФайл = ИсходныйФайл.Скопировать();
	КопияФайлаСсылка = МенеджерОбъекта.ПолучитьСсылку();
	НовыйФайл.УстановитьСсылкуНового(КопияФайлаСсылка);
	НовыйФайл.ВладелецФайла = ВладелецНовогоФайла.Ссылка;
	НовыйФайл.Редактирует = Справочники.Пользователи.ПустаяСсылка();
	
	НовыйФайл.ТекстХранилище = Новый ХранилищеЗначения(ИсходныйФайл.ТекстХранилище.Получить());
	НовыйФайл.ФайлХранилище  = Новый ХранилищеЗначения(ИсходныйФайл.ФайлХранилище.Получить());
	
	ДвоичныеДанные = РаботаСФайлами.ДвоичныеДанныеФайла(ИсходныйФайл);
	ДвоичныеДанныеВХранилищеЗначения = Новый ХранилищеЗначения(ДвоичныеДанные);
	НовыйФайл.ТипХраненияФайла = РаботаСФайламиСлужебный.ТипХраненияФайлов();
	
	Если РаботаСФайламиСлужебный.ТипХраненияФайлов() = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		
		ЗаписатьФайлВИнформационнуюБазу(КопияФайлаСсылка, ДвоичныеДанныеВХранилищеЗначения);
		
	Иначе
		// Добавить в один из томов (где есть свободное место).
		СведенияОФайле = РаботаСФайламиСлужебный.ДобавитьФайлВТом(ДвоичныеДанные, НовыйФайл.ДатаМодификацииУниверсальная,
		НовыйФайл.Наименование, НовыйФайл.Расширение);
		НовыйФайл.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
		НовыйФайл.Том = СведенияОФайле.Том;
	КонецЕсли;
	НовыйФайл.Записать();
	
	Если НовыйФайл.ХранитьВерсии Тогда
		
		СведенияОФайле = РаботаСФайламиКлиентСервер.СведенияОФайле("ФайлСВерсией");
		СведенияОФайле.ИмяБезРасширения = НовыйФайл.Наименование;
		СведенияОФайле.Размер = НовыйФайл.ТекущаяВерсия.Размер;
		СведенияОФайле.РасширениеБезТочки = НовыйФайл.ТекущаяВерсия.Расширение;
		СведенияОФайле.АдресВременногоХранилищаФайла = ДвоичныеДанныеВХранилищеЗначения;
		СведенияОФайле.АдресВременногоХранилищаТекста = НовыйФайл.ТекущаяВерсия.ТекстХранилище;
		СведенияОФайле.СсылкаНаВерсиюИсточник = НовыйФайл.ТекущаяВерсия;
		СведенияОФайле.Зашифрован = НовыйФайл.Зашифрован;
		Версия = РаботаСФайламиСлужебный.СоздатьВерсию(НовыйФайл.Ссылка, СведенияОФайле);
		РаботаСФайламиСлужебный.ОбновитьВерсиюВФайле(НовыйФайл.Ссылка, Версия, НовыйФайл.ТекущаяВерсия.ТекстХранилище);
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		
		МодульЭлектроннаяПодписьСлужебный = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодписьСлужебный");
		ДоступнаЭлектроннаяПодпись = МодульЭлектроннаяПодписьСлужебный.ДоступнаЭлектроннаяПодпись(ТипЗнч(ИсходныйФайл));
		Если ДоступнаЭлектроннаяПодпись Тогда
			
			МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
			
			Если ИсходныйФайл.ПодписанЭП Тогда
				
				ФайлОбъект = НовыйФайл.ПолучитьОбъект();
				ФайлОбъект.ПодписанЭП = Истина;
				ФайлОбъект.Записать();
				
				ЭлектронныеПодписиИсходногоФайла = МодульЭлектроннаяПодпись.УстановленныеПодписи(ИсходныйФайл);
				Для Каждого ЭП Из ЭлектронныеПодписиИсходногоФайла Цикл
					МенеджерЗаписи = РегистрыСведений["ЭлектронныеПодписи"].СоздатьМенеджерЗаписи();
					МенеджерЗаписи.ПодписанныйОбъект = НовыйФайл;
					ЗаполнитьЗначенияСвойств(МенеджерЗаписи, ЭП);
					МенеджерЗаписи.Записать(Истина);
				КонецЦикла;
				
			КонецЕсли;
			
			Если ИсходныйФайл.Зашифрован Тогда
				
				ФайлОбъект = НовыйФайл.ПолучитьОбъект();
				ФайлОбъект.Зашифрован = Истина;
				
				ЭлектронныеПодписиИсходногоФайла = МодульЭлектроннаяПодпись.СертификатыШифрования(ИсходныйФайл);
				Для Каждого Сертификат Из ЭлектронныеПодписиИсходногоФайла Цикл
					МенеджерЗаписи = РегистрыСведений["СертификатыШифрования"].СоздатьМенеджерЗаписи();
					МенеджерЗаписи.ЗашифрованныйОбъект = НовыйФайл;
					ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Сертификат);
					МенеджерЗаписи.Записать(Истина);
				КонецЦикла;
				// Чтобы прошла запись ранее подписанного объекта.
				ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
				ФайлОбъект.Записать();
				
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	РаботаСФайламиПереопределяемый.ЗаполнитьРеквизитыФайлаИзИсходногоФайла(НовыйФайл, ИсходныйФайл);
	
	Возврат НовыйФайл;
	
КонецФункции

// Переносит Файл в другую папку.
//
// Параметры:
//  ДанныеФайла  - структура с данными файла.
//  Папка - СправочникСсылка.ПапкиФайлов - ссылка на папку, куда нужно переместить файл.
//
Процедура ПеренестиФайл(ДанныеФайла, Папка) 
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных = Новый БлокировкаДанных;
		ЭлементБлокировкиДанных = БлокировкаДанных.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ДанныеФайла.Ссылка)).ПолноеИмя());
		ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", ДанныеФайла.Ссылка);
		БлокировкаДанных.Заблокировать();	
		ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
		ФайлОбъект.Заблокировать();
		ФайлОбъект.ВладелецФайла = Папка;
		ФайлОбъект.Записать();
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Переносит Файлы в другую папку.
//
// Параметры:
//  ОбъектыСсылка - Массив - массив ссылок на файлы.
//  Папка - СправочникСсылка.ПапкиФайлов - ссылка на папку, куда нужно переместить файлы.
//
Функция ПеренестиФайлы(ОбъектыСсылка, Папка) Экспорт 
	
	ДанныеФайлов = Новый Массив;
	
	Для Каждого ФайлСсылка Из ОбъектыСсылка Цикл
		ПеренестиФайл(ФайлСсылка, Папка);
		ДанныеФайла = ДанныеФайла(ФайлСсылка);
		ДанныеФайлов.Добавить(ДанныеФайла);
	КонецЦикла;
	
	Возврат ДанныеФайлов;
	
КонецФункции

// Получает РедактируетТекущийПользователь - в привилегированном режиме.
// Параметры:
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла.
//
// Возвращаемое значение:
//   Булево - Истина, если файл редактирует текущий пользователь.
//
Функция ПолучитьРедактируетТекущийПользователь(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Файлы.Редактирует КАК Редактирует
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВерсииФайлов КАК ВерсииФайлов
	|		ПО (ИСТИНА)
	|ГДЕ
	|	ВерсииФайлов.Ссылка = &Версия
	|	И Файлы.Ссылка = ВерсииФайлов.Владелец";
	
	Запрос.Параметры.Вставить("Версия", ВерсияСсылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		РедактируетТекущийПользователь = (Выборка.Редактирует = Пользователи.ТекущийПользователь());
		Возврат РедактируетТекущийПользователь;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Получает данные файла и делает заем (checkout) - для экономии вызовов 
// клиент сервер поместили ПолучитьДанныеФайла и ЗанятьФайл в одну функцию.
// Параметры:
//  ФайлСсылка  - СправочникСсылка.Файлы - файл.
//  ДанныеФайла  - Структура - структура с данными файла.
//  СтрокаОшибки - строка, в которой возвращается причина ошибки в случае неуспеха (скажем "Файл занят другим
//                 пользователем").
//  УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция.
//
Функция ПолучитьДанныеФайлаИЗанятьФайл(ФайлСсылка, ДанныеФайла, СтрокаОшибки, УникальныйИдентификатор = Неопределено) Экспорт

	ДанныеФайла = ДанныеФайла(ФайлСсылка);

	СтрокаОшибки = "";
	Если НЕ РаботаСФайламиКлиентСервер.МожноЛиЗанятьФайл(ДанныеФайла, СтрокаОшибки) Тогда
		Возврат Ложь;
	КонецЕсли;	
	
	Если Не ЗначениеЗаполнено(ДанныеФайла.Редактирует) Тогда
		
		СтрокаОшибки = "";
		Если Не ЗанятьФайл(ДанныеФайла, СтрокаОшибки, УникальныйИдентификатор) Тогда 
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Получает ДанныеФайла для файлов и помещает в МассивДанныхФайла.
//  МассивФайлов - массив ссылок на файлы.
//  МассивДанныхФайла - массив структур с данными файлов.
//
Процедура ПолучитьДанныеДляМассиваФайлов(Знач МассивФайлов, МассивДанныхФайла) Экспорт
	
	Для Каждого Файл Из МассивФайлов Цикл
		ДанныеФайла = ДанныеФайла(Файл);
		МассивДанныхФайла.Добавить(ДанныеФайла);
	КонецЦикла;
	
КонецПроцедуры

// Получает данные файла для открытия и делает заем (checkout) - для экономии вызовов 
// клиент сервер поместили ДанныеФайлаДляОткрытия и ЗанятьФайл в одну функцию.
// Параметры:
//  ФайлСсылка  - СправочникСсылка.Файлы - файл.
//  ДанныеФайла  - Структура - структура с данными файла.
//  СтрокаОшибки - строка, в которой возвращается причина ошибки в случае неуспеха (скажем "Файл занят другим
//                 пользователем").
//  УникальныйИдентификатор - уникальный идентификатор формы.
//  РабочийКаталогВладельца - Строка - рабочий каталог владельца файла.
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция.
//
Функция ПолучитьДанныеФайлаДляОткрытияИЗанятьФайл(ФайлСсылка,
	ДанныеФайла,
	СтрокаОшибки,
	УникальныйИдентификатор = Неопределено,
	РабочийКаталогВладельца = Неопределено,
	ВерсияСсылка = Неопределено) Экспорт

	ДанныеФайла = ДанныеФайлаДляОткрытия(ФайлСсылка, ВерсияСсылка, УникальныйИдентификатор, РабочийКаталогВладельца);

	СтрокаОшибки = "";
	Если НЕ РаботаСФайламиКлиентСервер.МожноЛиЗанятьФайл(ДанныеФайла, СтрокаОшибки) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДанныеФайла.Редактирует) Тогда
		
		СтрокаОшибки = "";
		Если Не ЗанятьФайл(ДанныеФайла, СтрокаОшибки, УникальныйИдентификатор) Тогда 
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Выполняет ПоместитьВоВременноеХранилище (если файл хранится на диске) и возвращает нужную ссылку.
// Параметры:
// ВерсияСсылка - версия файла.
//  ИдентификаторФормы - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Строка  - навигационная ссылка во временном хранилище.
//
Функция ПолучитьНавигационнуюСсылкуДляОткрытия(ВерсияСсылка, ИдентификаторФормы = Неопределено) Экспорт
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ВерсияСсылка, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПоместитьВоВременноеХранилище(РаботаСФайлами.ДвоичныеДанныеФайла(ВерсияСсылка));
	
КонецФункции

// Выполняет ДанныеФайла и вычисляет РабочийКаталогВладельца.
//
// Параметры:
//  ФайлИлиВерсияСсылка     - СправочникСсылка.Файлы, СправочникСсылка.ВерсииФайлов - файл или версия файла.
//  РабочийКаталогВладельца - Строка - в ней возвращается рабочий каталог владельца файла.
//
// Возвращаемое значение:
//   Структура - структура с данными файла.
//
Функция ДанныеФайлаИРабочийКаталог(ФайлИлиВерсияСсылка, РабочийКаталогВладельца = Неопределено) Экспорт
	
	ДанныеФайла = ДанныеФайла(ФайлИлиВерсияСсылка);
	МетаданныеФайла = Метаданные.НайтиПоТипу(ТипЗнч(ФайлИлиВерсияСсылка));
	ВозможностьХранитьВерсии = Ложь;
	Если ОбщегоНазначения.ЕстьРеквизитОбъекта("ВладелецФайла", МетаданныеФайла) Тогда 
		ФайлСсылка = ФайлИлиВерсияСсылка;
		ВерсияСсылка = Неопределено;
		ВозможностьХранитьВерсии = ОбщегоНазначения.ЕстьРеквизитОбъекта("ТекущаяВерсия", МетаданныеФайла);
	Иначе
		ФайлСсылка = Неопределено;
		ВерсияСсылка = ФайлИлиВерсияСсылка;
	КонецЕсли;
	
	Если РабочийКаталогВладельца = Неопределено Тогда
		РабочийКаталогВладельца = РабочийКаталогПапки(ДанныеФайла.Владелец);
	КонецЕсли;
	ДанныеФайла.Вставить("РабочийКаталогВладельца", РабочийКаталогВладельца);
	
	Если ДанныеФайла.РабочийКаталогВладельца <> "" Тогда
		
		ПолноеИмяФайлаВРабочемКаталоге = "";
		ИмяКаталога = ""; // Путь к локальному кэш здесь не используется.
		ВРабочемКаталогеНаЧтение = Истина; // не используется 
		ВРабочемКаталогеВладельца = Истина;
		
		Если ВерсияСсылка <> Неопределено Тогда
			ПолноеИмяФайлаВРабочемКаталоге = ПолучитьПолноеИмяФайлаИзРегистра(ВерсияСсылка, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		ИначеЕсли ВозможностьХранитьВерсии И ЗначениеЗаполнено(ФайлСсылка.ТекущаяВерсия) Тогда
			ПолноеИмяФайлаВРабочемКаталоге = ПолучитьПолноеИмяФайлаИзРегистра(ФайлСсылка.ТекущаяВерсия, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		Иначе
			ПолноеИмяФайлаВРабочемКаталоге = ПолучитьПолноеИмяФайлаИзРегистра(ФайлСсылка, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		КонецЕсли;
		
		ДанныеФайла.Вставить("ПолноеИмяФайлаВРабочемКаталоге", ПолноеИмяФайлаВРабочемКаталоге);
	КонецЕсли;
	
	Возврат ДанныеФайла;
КонецФункции

// Делает ПолучитьДанныеФайла и вычисляет количество версий файла.
// Параметры:
//  ФайлСсылка  - СправочникСсылка.Файлы - файл.
//
// Возвращаемое значение:
//   Структура - структура с данными файла.
//
Функция ПолучитьДанныеФайлаИКоличествоВерсий(ФайлСсылка) Экспорт
	
	ДанныеФайла = ДанныеФайла(ФайлСсылка);
	КоличествоВерсий = ПолучитьКоличествоВерсий(ФайлСсылка);
	ДанныеФайла.Вставить("КоличествоВерсий", КоличествоВерсий);
	
	Возврат ДанныеФайла;
	
КонецФункции

// Формирует текст ошибки для помещения в журнал регистрации.
// Параметры:
//  ИнформацияОбОшибкеФункции  - ИнформацияОбОшибке
//  ФайлСсылка  - СправочникСсылка.Файлы - файл.
//
// Возвращаемое значение:
//   Строка - описание ошибки
//
Функция СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибкеФункции, ФайлСсылка)
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ссылка на файл: ""%1"".
		           |""%2"".'"),
		ПолучитьНавигационнуюСсылку(ФайлСсылка),
		ПодробноеПредставлениеОшибки(ИнформацияОбОшибкеФункции));
	
КонецФункции

// Освобождение Файла с получением данных.
// Параметры:
//  ФайлСсылка  - СправочникСсылка.Файлы - файл.
//  ДанныеФайла  - структура с данными файла.
//  УникальныйИдентификатор - уникальный идентификатор формы.
//
Процедура ПолучитьДанныеФайлаИОсвободитьФайл(ФайлСсылка, ДанныеФайла, УникальныйИдентификатор = Неопределено) Экспорт
	
	ДанныеФайла = ДанныеФайла(ФайлСсылка);
	ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор);
	
КонецПроцедуры

// Для записи изменений файла без его освобождения.
//
// Параметры:
//   ФайлСсылка                   - Структура - структура с данными файла.
//   СведенияОФайле               - Структура - см. РаботаСФайламиКлиентСервер.СведенияОФайле, в режиме "ФайлСВерсией".
//   ОтносительныйПутьКФайлу      - Строка    - относительный путь без пути рабочего каталога, например
//                                              "А1/Приказ.doc"; указывается, если НеМенятьЗаписьВРабочемКаталоге =
//                                              Ложь.
//   ПолныйПутьКФайлу             - Строка    - путь на клиенте в рабочем каталоге; указывается, если
//                                              НеМенятьЗаписьВРабочемКаталоге = Ложь.
//   ВРабочемКаталогеВладельца    - Булево    - файл находится в рабочем каталоге владельца.
//   УникальныйИдентификаторФормы - УникальныйИдентификатор - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Структура - со свойствами:
//     * Успешно     - Булево    - Истина, если создание версии выполнено (и файл бинарно изменен).
//     * ДанныеФайла - Структура - структура с данными файла.
//
Функция ПолучитьДанныеФайлаИСохранитьИзмененияФайла(ФайлСсылка, СведенияОФайле, 
	ОтносительныйПутьКФайлу, ПолныйПутьКФайлу, ВРабочемКаталогеВладельца,
	УникальныйИдентификаторФормы = Неопределено) Экспорт
	
	ДанныеФайла = ДанныеФайла(ФайлСсылка);
	Если Не ДанныеФайла.ФайлРедактируетТекущийПользователь Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;
	
	ВерсияСоздана = СохранитьИзмененияФайла(ФайлСсылка, СведенияОФайле, 
		Ложь, ОтносительныйПутьКФайлу, ПолныйПутьКФайлу, ВРабочемКаталогеВладельца,
		УникальныйИдентификаторФормы);
	Возврат Новый Структура("Успешно,ДанныеФайла", ВерсияСоздана, ДанныеФайла);	
	
КонецФункции

// Получает синтетический рабочий каталог папки на диске (он может прийти от родительской папки).
// Параметры:
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла.
//
// Возвращаемое значение:
//   Строка  - рабочий каталог.
//
Функция РабочийКаталогПапки(СсылкаПапки) Экспорт
	
	Если Не ЭтоСправочникФайлы(СсылкаПапки) Тогда
		Возврат ""
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	РабочийКаталог = "";
	
	// Подготовить структуру отбора по измерениям.
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Папка", СсылкаПапки);
	СтруктураОтбора.Вставить("Пользователь", Пользователи.ТекущийПользователь());
	
	// Получить структуру с данными ресурсов записи.
	СтруктураРесурсов = РегистрыСведений.РабочиеКаталогиФайлов.Получить(СтруктураОтбора);
	
	// Получить путь из регистра
	РабочийКаталог = СтруктураРесурсов.Путь;
	
	Если НЕ ПустаяСтрока(РабочийКаталог) Тогда
		// Добавляем слэш в конце, если его нет.
		РабочийКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(РабочийКаталог);
	КонецЕсли;
	
	Возврат РабочийКаталог;
	
КонецФункции

// Сохраняет в регистре сведений рабочий каталог папки.
// Параметры:
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла.
//  РабочийКаталогВладельца - Строка - рабочий каталог папки.
//
Процедура СохранитьРабочийКаталогПапки(СсылкаПапки, РабочийКаталогПапки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.РабочиеКаталогиФайлов.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Папка.Установить(СсылкаПапки);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());
	
	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Папка = СсылкаПапки;
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();
	НоваяЗапись.Путь = РабочийКаталогПапки;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Сохраняет в регистре сведений рабочий каталог папки и
// заменяет пути в регистре сведений ФайлыВРабочемКаталоге.
//
// Параметры:
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла.
//  РабочийКаталогПапки - Строка - рабочий каталог папки.
//  ИмяКаталогаПрежнееЗначение - Строка - прежнее значение рабочего каталога.
//
Процедура СохранитьРабочийКаталогПапкиИЗаменитьПутиВРегистре(СсылкаПапки,
                                                        РабочийКаталогПапки,
                                                        ИмяКаталогаПрежнееЗначение) Экспорт
	
	СохранитьРабочийКаталогПапки(СсылкаПапки, РабочийКаталогПапки);
	
	// Ниже заменяем пути в регистре сведений ФайлыВРабочемКаталоге.
	УстановитьПривилегированныйРежим(Истина);
	
	СписокДляЗамены = Новый Массив;
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	// Для каждой нашей записи находим запись в регистре сведений - оттуда берем поле Версия и Редактирует.
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("Пользователь", ТекущийПользователь);
	ЗапросВРегистр.УстановитьПараметр("Путь", ИмяКаталогаПрежнееЗначение + "%");
	ЗапросВРегистр.Текст =
	"ВЫБРАТЬ
	|	ФайлыВРабочемКаталоге.Файл КАК Файл,
	|	ФайлыВРабочемКаталоге.Путь КАК Путь,
	|	ФайлыВРабочемКаталоге.Размер КАК Размер,
	|	ФайлыВРабочемКаталоге.ДатаПомещенияВРабочийКаталог КАК ДатаПомещенияВРабочийКаталог,
	|	ФайлыВРабочемКаталоге.НаЧтение КАК НаЧтение
	|ИЗ
	|	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	|ГДЕ
	|	ФайлыВРабочемКаталоге.Пользователь = &Пользователь
	|	И ФайлыВРабочемКаталоге.ВРабочемКаталогеВладельца = ИСТИНА
	|	И ФайлыВРабочемКаталоге.Путь ПОДОБНО &Путь";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		НовыйПуть = Выборка.Путь;
		НовыйПуть = СтрЗаменить(НовыйПуть, ИмяКаталогаПрежнееЗначение, РабочийКаталогПапки);
		
		СтруктураЗаписи = Новый Структура;
		СтруктураЗаписи.Вставить("Файл",                         Выборка.Файл);
		СтруктураЗаписи.Вставить("Путь",                         НовыйПуть);
		СтруктураЗаписи.Вставить("Размер",                       Выборка.Размер);
		СтруктураЗаписи.Вставить("ДатаПомещенияВРабочийКаталог", Выборка.ДатаПомещенияВРабочийКаталог);
		СтруктураЗаписи.Вставить("НаЧтение",                     Выборка.НаЧтение);
		
		СписокДляЗамены.Добавить(СтруктураЗаписи);
		
	КонецЦикла;
	
	Для Каждого СтруктураЗаписи Из СписокДляЗамены Цикл
		
		ВРабочемКаталогеВладельца = Истина;
		ЗаписатьСтруктуруЗаписиВРегистр(
			СтруктураЗаписи.Файл,
			СтруктураЗаписи.Путь,
			СтруктураЗаписи.Размер,
			СтруктураЗаписи.ДатаПомещенияВРабочийКаталог,
			СтруктураЗаписи.НаЧтение,
			ВРабочемКаталогеВладельца);
		
	КонецЦикла;
	
КонецПроцедуры

// После смены пути запишем заново - с теми же значениями остальных полей.
// Параметры:
//  Версия - СправочникСсылка.ВерсииФайлов - версия.
//  Путь - Строка - относительный путь внутри рабочего каталога.
//  Размер  - размер файла в байтах.
//  ДатаПомещенияВРабочийКаталог - Дата - дата помещения файла в рабочий каталог.
//  НаЧтение - Булево - файл помещен на чтение.
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге).
//
Процедура ЗаписатьСтруктуруЗаписиВРегистр(Файл,
                                          Путь,
                                          Размер,
                                          ДатаПомещенияВРабочийКаталог,
                                          НаЧтение,
                                          ВРабочемКаталогеВладельца)
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Файл, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Файл.Установить(Файл);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Файл = Файл;
	НоваяЗапись.Путь = Путь;
	НоваяЗапись.Размер = Размер;
	НоваяЗапись.ДатаПомещенияВРабочийКаталог = ДатаПомещенияВРабочийКаталог;
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();

	НоваяЗапись.НаЧтение = НаЧтение;
	НоваяЗапись.ВРабочемКаталогеВладельца = ВРабочемКаталогеВладельца;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Очищает в регистре сведений рабочий каталог папки.
// Параметры:
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла.
//
Процедура ОчиститьРабочийКаталог(СсылкаПапки) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.РабочиеКаталогиФайлов.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Папка.Установить(СсылкаПапки);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());
	
	// Не добавляем записи в набор - чтобы все стереть.
	НаборЗаписей.Записать();
	
	// Для дочерних папок очищаем рабочие каталоги.
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПапкиФайлов.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПапкиФайлов КАК ПапкиФайлов
	|ГДЕ
	|	ПапкиФайлов.Родитель = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаПапки);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		ОчиститьРабочийКаталог(Выборка.Ссылка);
	КонецЦикла;
	
КонецПроцедуры

// Находит запись в регистре сведений ФайлыВРабочемКаталоге по пути файла на диске (относительному).
//
// Параметры:
//  ИмяФайла - Строка - имя файла с относительным путем (без пути к рабочему каталогу).
//
// Возвращаемое значение:
//  Структура со свойствами:
//    Версия            - СправочникСсылка.ВерсииФайлов - найденная версия.
//    ДатаПомещения     - Дата помещения файла в рабочий каталог.
//    Владелец          - Ссылка - владелец файла.
//    НомерВерсии       - Число - номер версии.
//    ВРегистреНаЧтение - Булево - значение ресурса НаЧтение.
//    ВРегистреКодФайла - Число сюда помещается код файла.
//    ВРегистреПапка    - СправочникСсылка.ПапкиФайлов - папка файла.
//
Функция НайтиВРегистреПоПути(ИмяФайла) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НайденныеСвойства = Новый Структура;
	НайденныеСвойства.Вставить("ФайлЕстьВРегистре", Ложь);
	НайденныеСвойства.Вставить("Файл", Справочники.ВерсииФайлов.ПолучитьСсылку());
	НайденныеСвойства.Вставить("ДатаПомещения");
	НайденныеСвойства.Вставить("Владелец");
	НайденныеСвойства.Вставить("НомерВерсии");
	НайденныеСвойства.Вставить("ВРегистреНаЧтение");
	НайденныеСвойства.Вставить("ВРегистреКодФайла");
	НайденныеСвойства.Вставить("ВРегистреПапка");
	
	// Для каждого по пути находим запись в регистре сведений - оттуда берем поле.
	// Версия и Размер и ДатаПомещенияВРабочийКаталог.
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("ИмяФайла", ИмяФайла);
	ЗапросВРегистр.УстановитьПараметр("Пользователь", Пользователи.ТекущийПользователь());
	ЗапросВРегистр.Текст =
	"ВЫБРАТЬ
	|	ФайлыВРабочемКаталоге.Файл КАК Файл,
	|	ФайлыВРабочемКаталоге.ДатаПомещенияВРабочийКаталог КАК ДатаПомещения,
	|	ФайлыВРабочемКаталоге.НаЧтение КАК ВРегистреНаЧтение,
	|	ВЫБОР
	|		КОГДА ТИПЗНАЧЕНИЯ(ФайлыВРабочемКаталоге.Файл) = ТИП(Справочник.ВерсииФайлов)
	|			ТОГДА ФайлыВРабочемКаталоге.Файл.Владелец
	|		ИНАЧЕ ФайлыВРабочемКаталоге.Файл
	|	КОНЕЦ КАК Владелец,
	|	ВЫБОР
	|		КОГДА ТИПЗНАЧЕНИЯ(ФайлыВРабочемКаталоге.Файл) = ТИП(Справочник.ВерсииФайлов)
	|			ТОГДА ФайлыВРабочемКаталоге.Файл.НомерВерсии
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК НомерВерсии,
	|	ВЫБОР
	|		КОГДА ТИПЗНАЧЕНИЯ(ФайлыВРабочемКаталоге.Файл) = ТИП(Справочник.ВерсииФайлов)
	|			ТОГДА ФайлыВРабочемКаталоге.Файл.Владелец.ВладелецФайла
	|		ИНАЧЕ ФайлыВРабочемКаталоге.Файл.ВладелецФайла
	|	КОНЕЦ КАК ВРегистреПапка
	|ИЗ
	|	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	|ГДЕ
	|	ФайлыВРабочемКаталоге.Путь = &ИмяФайла
	|	И ФайлыВРабочемКаталоге.Пользователь = &Пользователь";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		НайденныеСвойства.ФайлЕстьВРегистре = Истина;
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		ЗаполнитьЗначенияСвойств(НайденныеСвойства, Выборка);
	КонецЕсли;
	
	Возврат НайденныеСвойства;
	
КонецФункции

// Находит в регистре сведений ФайлыВРабочемКаталоге информацию о ВерсииФайла (путь к файлу версии в рабочем каталоге,
// и статус - на чтение или на редактирование).
// Параметры:
//  Версия - СправочникСсылка.ВерсииФайлов - версия.
//  ИмяКаталога - путь рабочего каталога.
//  ВРабочемКаталогеНаЧтение - Булево - файл помещен на чтение.
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге).
//
Функция ПолучитьПолноеИмяФайлаИзРегистра(Версия,
                                         ИмяКаталога,
                                         ВРабочемКаталогеНаЧтение,
                                         ВРабочемКаталогеВладельца) Экспорт
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Версия, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПолноеИмяФайла = "";
	
	// Подготовить структуру отбора по измерениям.
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Файл", Версия.Ссылка);

	СтруктураОтбора.Вставить("Пользователь", Пользователи.АвторизованныйПользователь());
	
	// Получить структуру с данными ресурсов записи.
	СтруктураРесурсов = РегистрыСведений.ФайлыВРабочемКаталоге.Получить(СтруктураОтбора);
	
	// Получить путь из регистра
	ПолноеИмяФайла = СтруктураРесурсов.Путь;
	ВРабочемКаталогеНаЧтение = СтруктураРесурсов.НаЧтение;
	ВРабочемКаталогеВладельца = СтруктураРесурсов.ВРабочемКаталогеВладельца;
	Если ПолноеИмяФайла <> "" И ВРабочемКаталогеВладельца = Ложь Тогда
		ПолноеИмяФайла = ИмяКаталога + ПолноеИмяФайла;
	КонецЕсли;
	
	Возврат ПолноеИмяФайла;
	
КонецФункции

// Записать в регистр сведений ФайлыВРабочемКаталоге информацию о пути файла.
// Параметры:
//  ТекущаяВерсия - СправочникСсылка.ВерсииФайлов - версия.
//  ПолноеИмяФайла - имя с путем в рабочем каталоге.
//  НаЧтение - Булево - файл помещен на чтение.
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге).
//
Процедура ЗаписатьПолноеИмяФайлаВРегистр(ТекущаяВерсия,
                                         ПолноеИмяФайла,
                                         НаЧтение,
                                         ВРабочемКаталогеВладельца) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Файл.Установить(ТекущаяВерсия.Ссылка);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Файл = ТекущаяВерсия.Ссылка;
	НоваяЗапись.Путь = ПолноеИмяФайла;
	НоваяЗапись.Размер = ТекущаяВерсия.Размер;
	НоваяЗапись.ДатаПомещенияВРабочийКаталог = ТекущаяДатаСеанса();
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();

	НоваяЗапись.НаЧтение = НаЧтение;
	НоваяЗапись.ВРабочемКаталогеВладельца = ВРабочемКаталогеВладельца;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Удалить из регистра сведений ФайлыВРабочемКаталоге запись о данной версии файла.
// Параметры:
//  Версия - СправочникСсылка.ВерсииФайлов - версия.
//
Процедура УдалитьИзРегистра(Файл) Экспорт
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Файл, "Ссылка", Истина);
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Файл.Установить(Файл);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.АвторизованныйПользователь());
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Удалить из регистра сведений ФайлыВРабочемКаталоге все записи,
// кроме записей о файлах занятых текущим пользователем.
//
Процедура ОчиститьВсеСвоиКромеЗанятых() Экспорт
	
	// Отбираем все в регистре сведений. Перебираем - находим те, что не заняты текущим пользователем -
	//  и все удаляем - считаем, что на диске они уже удалены.
	
	УстановитьПривилегированныйРежим(Истина);
	
	СписокУдалить = Новый Массив;
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	// Для каждой нашей записи находим запись в регистре сведений - оттуда берем поле Версия и Редактирует.
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("Пользователь", ТекущийПользователь);
	ЗапросВРегистр.Текст =
	"ВЫБРАТЬ
	|	ФайлыВРабочемКаталоге.Файл КАК Файл,
	|	СведенияОФайлах.Редактирует КАК Редактирует
	|ИЗ
	|	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СведенияОФайлах КАК СведенияОФайлах
	|		ПО ФайлыВРабочемКаталоге.Файл = СведенияОФайлах.Файл
	|ГДЕ
	|	ФайлыВРабочемКаталоге.Пользователь = &Пользователь
	|	И ФайлыВРабочемКаталоге.ВРабочемКаталогеВладельца = ЛОЖЬ";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл
				
			Если Выборка.Редактирует <> ТекущийПользователь Тогда
				СписокУдалить.Добавить(Выборка.Файл);
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Для Каждого Файл Из СписокУдалить Цикл
		// Создать набор записей
		НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Файл.Установить(Файл);
		НаборЗаписей.Отбор.Пользователь.Установить(ТекущийПользователь);
		
		НаборЗаписей.Записать();
	КонецЦикла;
	
КонецПроцедуры

// Удалить из регистра сведений ФайлыВРабочемКаталоге запись о старой версии и внести запись о новой.
// Параметры:
//  СтараяВерсия - СправочникСсылка.ВерсииФайлов - старая версия.
//  НоваяВерсия - СправочникСсылка.ВерсииФайлов - новая версия.
//  ПолноеИмяФайла - имя с путем в рабочем каталоге.
//  ИмяКаталога - путь рабочего каталога.
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге).
//
Процедура УдалитьВерсиюИЗанестиИнформациюФайлаВРегистр(СтараяВерсия,
                                                       НоваяВерсия,
                                                       ПолноеИмяФайла,
                                                       ИмяКаталога,
                                                       ВРабочемКаталогеВладельца)
	
	УдалитьИзРегистра(СтараяВерсия);
	НаЧтение = Истина;
	ЗанестиИнформациюФайлаВРегистр(НоваяВерсия, ПолноеИмяФайла, ИмяКаталога, НаЧтение, 0, ВРабочемКаталогеВладельца);
	
КонецПроцедуры

// Записать в регистр сведений ФайлыВРабочемКаталоге информацию о пути файла.
//  Версия - СправочникСсылка.ВерсииФайлов - версия.
//  ПолныйПуть - Строка - полный путь файла.
//  ИмяКаталога - путь рабочего каталога.
//  НаЧтение - Булево - файл помещен на чтение.
//  РазмерФайла  - размер файла в байтах.
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге).
//
Процедура ЗанестиИнформациюФайлаВРегистр(Версия,
                                         ПолныйПуть,
                                         ИмяКаталога,
                                         НаЧтение,
                                         РазмерФайла,
                                         ВРабочемКаталогеВладельца) Экспорт
	ПолноеИмяФайла = ПолныйПуть;
	
	Если ВРабочемКаталогеВладельца = Ложь Тогда
		Если СтрНайти(ПолныйПуть, ИмяКаталога) = 1 Тогда
			ПолноеИмяФайла = Сред(ПолныйПуть, СтрДлина(ИмяКаталога) + 1);
		КонецЕсли;
	КонецЕсли;
	
	ЕстьПраваНаОбъект = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Версия, "Ссылка", Истина);
	
	Если ЕстьПраваНаОбъект = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Файл.Установить(Версия.Ссылка);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.АвторизованныйПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Файл = Версия.Ссылка;
	НоваяЗапись.Путь = ПолноеИмяФайла;

	Если РазмерФайла <> 0 Тогда
		НоваяЗапись.Размер = РазмерФайла;
	Иначе
		НоваяЗапись.Размер = Версия.Размер;
	КонецЕсли;

	НоваяЗапись.ДатаПомещенияВРабочийКаталог = ТекущаяДатаСеанса();
	НоваяЗапись.Пользователь = Пользователи.АвторизованныйПользователь();
	НоваяЗапись.НаЧтение = НаЧтение;
	НоваяЗапись.ВРабочемКаталогеВладельца = ВРабочемКаталогеВладельца;

	НаборЗаписей.Записать();
	
КонецПроцедуры

// Формирует отчет для файлов с ошибками.
//
// Параметры:
//   МассивИменФайловСОшибками - массив строк путей к файлам.
//
// Возвращаемое значение:
//   ТабличныйДокумент с отчетом.
//
Функция ИмпортФайловСформироватьОтчет(МассивИменФайловСОшибками) Экспорт
	
	Документ = Новый ТабличныйДокумент;
	Макет = Справочники.Файлы.ПолучитьМакет("МакетОтчета");
	
	ОбластьЗаголовок = Макет.ПолучитьОбласть("Заголовок");
	ОбластьЗаголовок.Параметры.Описание = НСтр("ru = 'Не удалось загрузить следующие файлы:'");
	Документ.Вывести(ОбластьЗаголовок);
	
	ОбластьСтрока = Макет.ПолучитьОбласть("Строка");

	Для Каждого Выборка Из МассивИменФайловСОшибками Цикл
		ОбластьСтрока.Параметры.Название = Выборка.ИмяФайла;
		ОбластьСтрока.Параметры.Ошибка = Выборка.Ошибка;
		Документ.Вывести(ОбластьСтрока);
	КонецЦикла;
	
	Отчет = Новый ТабличныйДокумент;
	Отчет.Вывести(Документ);

	Возврат Отчет;
	
КонецФункции

// Сортирует массив структур по полю Дата - на сервере, т.к. на тонком клиенте нет ТаблицаЗначений.
//
// Параметры:
// МассивСтруктур - массив структур описаний файлов.
//
Процедура СортироватьМассивСтруктур(МассивСтруктур) Экспорт
	
	ТаблицаФайлов = Новый ТаблицаЗначений;
	ТаблицаФайлов.Колонки.Добавить("Путь");
	ТаблицаФайлов.Колонки.Добавить("Версия");
	ТаблицаФайлов.Колонки.Добавить("Размер");
	
	ТаблицаФайлов.Колонки.Добавить("ДатаПомещенияВРабочийКаталог", Новый ОписаниеТипов("Дата"));
	
	Для Каждого Строка Из МассивСтруктур Цикл
		НоваяСтрока = ТаблицаФайлов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка, "Путь, Размер, Версия, ДатаПомещенияВРабочийКаталог");
	КонецЦикла;
	
	// Сортировка по дате - в начале будут самые давно помещенные в рабочий каталог.
	ТаблицаФайлов.Сортировать("ДатаПомещенияВРабочийКаталог Возр");  
	
	МассивСтруктурВозврат = Новый Массив;
	
	Для Каждого Строка Из ТаблицаФайлов Цикл
		Запись = Новый Структура;
		Запись.Вставить("Путь", Строка.Путь);
		Запись.Вставить("Размер", Строка.Размер);
		Запись.Вставить("Версия", Строка.Версия);
		Запись.Вставить("ДатаПомещенияВРабочийКаталог", Строка.ДатаПомещенияВРабочийКаталог);
		МассивСтруктурВозврат.Добавить(Запись);
	КонецЦикла;
	
	МассивСтруктур = МассивСтруктурВозврат;
	
КонецПроцедуры

// Возвращает настройку - Спрашивать режим редактирования при открытии файла.
// Возвращаемое значение:
//   Булево - Спрашивать режим редактирования при открытии файла.
//
Функция СпрашиватьРежимРедактированияПриОткрытииФайла()
	СпрашиватьРежимРедактированияПриОткрытииФайла = 
		ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиОткрытияФайлов", "СпрашиватьРежимРедактированияПриОткрытииФайла");
	Если СпрашиватьРежимРедактированияПриОткрытииФайла = Неопределено Тогда
		СпрашиватьРежимРедактированияПриОткрытииФайла = Истина;
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиОткрытияФайлов", "СпрашиватьРежимРедактированияПриОткрытииФайла", СпрашиватьРежимРедактированияПриОткрытииФайла);
	КонецЕсли;
	
	Возврат СпрашиватьРежимРедактированияПриОткрытииФайла;
КонецФункции

// Считаем ДействиеПоДвойномуЩелчкуМыши - если первый раз - поставим правильное значение.
//
// Возвращаемое значение:
//   Строка - Действие по двойному щелчку мыши.
//
Функция ДействиеПоДвойномуЩелчкуМыши()
	
	КакОткрывать = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить(
		"НастройкиОткрытияФайлов", "ДействиеПоДвойномуЩелчкуМыши");
	
	Если КакОткрывать = Неопределено
	 ИЛИ КакОткрывать = Перечисления.ДействияСФайламиПоДвойномуЩелчку.ПустаяСсылка() Тогда
		
		КакОткрывать = Перечисления.ДействияСФайламиПоДвойномуЩелчку.ОткрыватьФайл;
		
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить(
			"НастройкиОткрытияФайлов", "ДействиеПоДвойномуЩелчкуМыши", КакОткрывать);
	КонецЕсли;
	
	Если КакОткрывать = Перечисления.ДействияСФайламиПоДвойномуЩелчку.ОткрыватьФайл Тогда
		Возврат "ОткрыватьФайл";
	Иначе
		Возврат "ОткрыватьКарточку";
	КонецЕсли;
	
КонецФункции

// Функция меняет ВладелецФайла объектам типа Справочник.Файл, вернет Истина при успехе.
// Параметры:
//  МассивСсылокНаФайлы - Массив - массив файлов.
//  НовыйВладелецФайла  - ЛюбаяСсылка - новый владелец файла.
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция.
//
Функция УстановитьВладельцаФайла(МассивСсылокНаФайлы, НовыйВладелецФайла) Экспорт
	Если МассивСсылокНаФайлы.Количество() = 0 Или Не ЗначениеЗаполнено(НовыйВладелецФайла) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Тот же родитель - ничего делать не надо.
	Если МассивСсылокНаФайлы.Количество() > 0 И (МассивСсылокНаФайлы[0].ВладелецФайла = НовыйВладелецФайла) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Для Каждого ФайлПринятый Из МассивСсылокНаФайлы Цикл
			ЭлементБлокировки = Блокировка.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ФайлПринятый)).ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка",ФайлПринятый);
		КонецЦикла;
		Блокировка.Заблокировать();
	
		Для Каждого ФайлПринятый Из МассивСсылокНаФайлы Цикл
			ФайлОбъект = ФайлПринятый.ПолучитьОбъект();
			ФайлОбъект.Заблокировать();
			ФайлОбъект.ВладелецФайла = НовыйВладелецФайла;
			ФайлОбъект.Записать();
		КонецЦикла;
	
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Функция меняет свойство Родитель объектам типа Справочник.ПапкиФайла, вернет Истина при успехе, 
// в переменной НайденоЗацикливание вернет Истина, если одну из папок переносим в ее же дочернюю папку.
//
// Параметры:
//  МассивСсылокНаФайлы - Массив - массив файлов.
//  НовыйРодитель  - ЛюбаяСсылка - новый владелец файла.
//  НайденоЗацикливание - Булево - возвращает Истина, если найдено зацикливание.
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция.
//
Функция СменитьРодителяПапок(МассивСсылокНаФайлы, НовыйРодитель, НайденоЗацикливание) Экспорт
	НайденоЗацикливание = Ложь;
	
	Если МассивСсылокНаФайлы.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Тот же родитель - ничего делать не надо.
	Если МассивСсылокНаФайлы.Количество() = 1 И (МассивСсылокНаФайлы[0].Родитель = НовыйРодитель) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ЕстьЗацикливание(МассивСсылокНаФайлы, НовыйРодитель) Тогда
		НайденоЗацикливание = Истина;
		Возврат Ложь;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Для Каждого ФайлПринятый Из МассивСсылокНаФайлы Цикл
			ЭлементБлокировки = Блокировка.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ФайлПринятый)).ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка",ФайлПринятый);
		КонецЦикла;
		Блокировка.Заблокировать();
	
		Для Каждого ФайлПринятый Из МассивСсылокНаФайлы Цикл
			ФайлОбъект = ФайлПринятый.ПолучитьОбъект();
			ФайлОбъект.Заблокировать();
			ФайлОбъект.Родитель = НовыйРодитель;
			ФайлОбъект.Записать();
		КонецЦикла;
	
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Получает данные для переноса файла из одного списка приложенных файлов в другой.
//
// Параметры:
// ФайлМассив - массив ссылок на файлы или СправочникСсылка.Файлы.
// ВладелецФайла - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   ТаблицаЗначений - описания файлов.
//
Функция ПолучитьДанныеДляПереносаВПриложенныеФайлы(ФайлМассив, ВладелецФайла) Экспорт

	Если ТипЗнч(ФайлМассив) = Тип("Массив") Тогда 
		МассивФайлов = ФайлМассив;
	Иначе
		МассивФайлов = Новый Массив;
		МассивФайлов.Добавить(ФайлМассив);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Файлы.Ссылка КАК Ссылка,
	|	Файлы.Наименование КАК Наименование
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.ВладелецФайла = &ВладелецФайла";
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	ТаблРезультат = Запрос.Выполнить().Выгрузить();
	
	Результат = Новый Соответствие;
	Для Каждого ФайлСсылка Из МассивФайлов Цикл
		
		Если ТаблРезультат.Найти(ФайлСсылка, "Ссылка") <> Неопределено Тогда 
			Результат.Вставить(ФайлСсылка, "Пропустить");
		ИначеЕсли ТаблРезультат.Найти(ФайлСсылка.Наименование, "Наименование") <> Неопределено Тогда 
			Результат.Вставить(ФайлСсылка, "Обновить");
		Иначе
			Результат.Вставить(ФайлСсылка, "Скопировать");
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Копирует файлы при переносе из одного списка приложенных файлов в другой.
//
// Параметры:
//   ФайлМассив - Массив - массив ссылок на файлы или СправочникСсылка.Файлы.
//   ВладелецФайла - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   СправочникСсылка.Файлы - скопированный файл.
//
Функция СкопироватьФайлВПриложенных(ФайлМассив, ВладелецФайла) Экспорт
	
	Если ТипЗнч(ФайлМассив) = Тип("Массив") Тогда 
		МассивФайлов = ФайлМассив;
	Иначе
		МассивФайлов = Новый Массив;
		МассивФайлов.Добавить(ФайлМассив);
	КонецЕсли;
	
	Для Каждого ФайлСсылка Из МассивФайлов Цикл
		
		Источник = ФайлСсылка;
		ИсточникОбъект = Источник.ПолучитьОбъект();
		
		ПриемникОбъект = ИсточникОбъект.Скопировать();
		ПриемникОбъект.ВладелецФайла = ВладелецФайла;
		ПриемникОбъект.Записать();
		
		Приемник = ПриемникОбъект.Ссылка;
		
		Если Не Источник.ТекущаяВерсия.Пустая() Тогда
			
			ХранилищеФайла = Неопределено;
			Если Источник.ТекущаяВерсия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда 
				ХранилищеФайла = РаботаСФайлами.ХранилищеФайлаИзИнформационнойБазы(Источник.ТекущаяВерсия);
			КонецЕсли;
			
			СведенияОФайле = РаботаСФайламиКлиентСервер.СведенияОФайле("ФайлСВерсией");
			СведенияОФайле.ИмяБезРасширения = Приемник.Наименование;
			СведенияОФайле.Размер = Источник.ТекущаяВерсия.Размер;
			СведенияОФайле.РасширениеБезТочки = Источник.ТекущаяВерсия.Расширение;
			СведенияОФайле.АдресВременногоХранилищаФайла = ХранилищеФайла;
			СведенияОФайле.АдресВременногоХранилищаТекста = Источник.ТекущаяВерсия.ТекстХранилище;
			СведенияОФайле.СсылкаНаВерсиюИсточник = Источник.ТекущаяВерсия;
			Версия = РаботаСФайламиСлужебный.СоздатьВерсию(Приемник, СведенияОФайле);
			РаботаСФайламиСлужебный.ОбновитьВерсиюВФайле(Приемник, Версия, Источник.ТекущаяВерсия.ТекстХранилище);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Приемник;
	
КонецФункции

// Обновляет версии одноименных файлов при переносе из одного списка приложенных файлов в другой.
//
// Параметры:
//   ФайлМассив - массив ссылок на файлы или СправочникСсылка.Файлы.
//   ВладелецФайла - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   СправочникСсылка.Файлы - скопированный файл.
//
Функция ОбновитьФайлВПриложенных(ФайлМассив, ВладелецФайла) Экспорт
	
	Если ТипЗнч(ФайлМассив) = Тип("Массив") Тогда 
		МассивФайлов = ФайлМассив;
	Иначе
		МассивФайлов = Новый Массив;
		МассивФайлов.Добавить(ФайлМассив);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Файлы.Ссылка КАК Ссылка,
	|	Файлы.Наименование КАК ПолноеНаименование
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.ВладелецФайла = &ВладелецФайла";
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	
	ТаблРезультат = Запрос.Выполнить().Выгрузить();
	Для Каждого ФайлСсылка Из МассивФайлов Цикл
		
		НайденнаяСтрока = ТаблРезультат.Найти(ФайлСсылка.Наименование, "ПолноеНаименование");
		
		Источник = ФайлСсылка;
		Приемник = НайденнаяСтрока.Ссылка;
		
		Если Не Источник.ТекущаяВерсия.Пустая() Тогда
			
			ХранилищеФайла = Неопределено;
			Если Источник.ТекущаяВерсия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда 
				ХранилищеФайла = РаботаСФайлами.ХранилищеФайлаИзИнформационнойБазы(Источник.ТекущаяВерсия);
			КонецЕсли;
			
			СведенияОФайле = РаботаСФайламиКлиентСервер.СведенияОФайле("ФайлСВерсией");
			СведенияОФайле.ИмяБезРасширения = Приемник.Наименование;
			СведенияОФайле.Размер = Источник.ТекущаяВерсия.Размер;
			СведенияОФайле.РасширениеБезТочки = Источник.ТекущаяВерсия.Расширение;
			СведенияОФайле.АдресВременногоХранилищаФайла = ХранилищеФайла;
			СведенияОФайле.АдресВременногоХранилищаТекста = Источник.ТекущаяВерсия.ТекстХранилище;
			СведенияОФайле.СсылкаНаВерсиюИсточник = Источник.ТекущаяВерсия;
			Версия = РаботаСФайламиСлужебный.СоздатьВерсию(Приемник, СведенияОФайле);
			РаботаСФайламиСлужебный.ОбновитьВерсиюВФайле(Приемник, Версия, Источник.ТекущаяВерсия.ТекстХранилище);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Приемник;
	
КонецФункции

// Заполняет условное оформление списка файлов.
//
// Параметры:
// Список - динамический список.
//
Процедура ЗаполнитьУсловноеОформлениеСпискаФайлов(Список) Экспорт
	
	УсловноеОформлениеКД = Список.КомпоновщикНастроек.Настройки.УсловноеОформление;
	УсловноеОформлениеКД.ИдентификаторПользовательскойНастройки = "ОсновноеОформление";
	
	Элемент = УсловноеОформлениеКД.Элементы.Добавить();
	Элемент.Использование = Истина;
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ТекстЗапрещеннойЯчейкиЦвет);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.Использование = Истина;
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Редактирует");
	
	Если ЕстьДублирующийсяЭлемент(УсловноеОформлениеКД.Элементы, Элемент) Тогда
		УсловноеОформлениеКД.Элементы.Удалить(Элемент);
	КонецЕсли;
	
	Элемент = УсловноеОформлениеКД.Элементы.Добавить();
	Элемент.Использование = Истина;
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ФайлЗанятыйТекущимПользователем);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.Использование = Истина;
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Редактирует");
	Отбор.ПравоеЗначение = Пользователи.ТекущийПользователь();
	
	Если ЕстьДублирующийсяЭлемент(УсловноеОформлениеКД.Элементы, Элемент) Тогда
		УсловноеОформлениеКД.Элементы.Удалить(Элемент);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет условное оформление списка папок.
//
// Параметры:
// Список - динамический список.
//
Процедура ЗаполнитьУсловноеОформлениеСпискаПапок(Папки) Экспорт
	
	УсловноеОформлениеКД = Папки.КомпоновщикНастроек.Настройки.УсловноеОформление;
	УсловноеОформлениеКД.ИдентификаторПользовательскойНастройки = "ОсновноеОформление";
	
	Элемент = УсловноеОформлениеКД.Элементы.Добавить();
	Элемент.Использование = Истина;
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ТекстЗапрещеннойЯчейкиЦвет);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.Использование = Истина;
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ПапкаСинхронизируется");
	Отбор.ПравоеЗначение = Истина;
	
	Если ЕстьДублирующийсяЭлемент(УсловноеОформлениеКД.Элементы, Элемент) Тогда
		УсловноеОформлениеКД.Элементы.Удалить(Элемент);
	КонецЕсли;
	
КонецПроцедуры

// Получает данные файла для открытия и читает из общих настроек ПапкаДляСохранитьКак.
//
// Параметры:
//  ФайлИлиВерсияСсылка     - СправочникСсылка.Файлы, СправочникСсылка.ВерсииФайлов - файл или версия файла.
//  ИдентификаторФормы      - УникальныйИдентификатор - уникальный идентификатор формы.
//  РабочийКаталогВладельца - Строка - рабочий каталог владельца файла.
//
// Возвращаемое значение:
//   Структура - структура с данными файла.
//
Функция ДанныеФайлаДляСохранения(ФайлСсылка, ВерсияСсылка = Неопределено, ИдентификаторФормы = Неопределено, РабочийКаталогВладельца = Неопределено) Экспорт

	ДанныеФайла = ДанныеФайлаДляОткрытия(ФайлСсылка, ВерсияСсылка, ИдентификаторФормы, РабочийКаталогВладельца);
	
	ПапкаДляСохранитьКак = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПрограммы", "ПапкаДляСохранитьКак");
	ДанныеФайла.Вставить("ПапкаДляСохранитьКак", ПапкаДляСохранитьКак);

	Возврат ДанныеФайла;
КонецФункции

// Получает ДанныеФайла и НавигационнуюСсылкуВерсии всех подчиненных файлов.
// Параметры:
//  ФайлСсылка - СправочникСсылка.Файлы - файл.
//  ИдентификаторФормы - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Массив - массив структур с данными файлов.
Функция ДанныеФайлаИНавигационнаяСсылкаВсехВерсийФайла(ФайлСсылка, ИдентификаторФормы) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ВерсииФайлов.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов
		|ГДЕ
		|	ВерсииФайлов.Владелец = &ФайлСсылка";
	
	Запрос.УстановитьПараметр("ФайлСсылка", ФайлСсылка);
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	МассивВозврата = Новый Массив;
	Пока Выборка.Следующий() Цикл
		
		ВерсияСсылка = Выборка.Ссылка;
		ДанныеФайла = ДанныеФайла(ФайлСсылка, ВерсияСсылка);
		НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуВоВременномХранилище(ВерсияСсылка, ИдентификаторФормы);
		
		СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии, ВерсияСсылка", 
			ДанныеФайла, НавигационнаяСсылкаВерсии, ВерсияСсылка);
		МассивВозврата.Добавить(СтруктураВозврата);
	КонецЦикла;
	
	// Если не хранятся версии, то зашифровываем файл.
	Если Не ФайлСсылка.ХранитьВерсии Или Не ЗначениеЗаполнено(ФайлСсылка.ТекущаяВерсия) Тогда
		ДанныеФайла = ДанныеФайла(ФайлСсылка);
		НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуВоВременномХранилище(ФайлСсылка, ИдентификаторФормы);
		
		СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии, ВерсияСсылка", 
			ДанныеФайла, НавигационнаяСсылкаВерсии, ФайлСсылка);
		МассивВозврата.Добавить(СтруктураВозврата);
	КонецЕсли;
	
	Возврат МассивВозврата;
КонецФункции

// Делает ПоместитьВоВременноеХранилище (если файл хранится на диске) и возвращает нужную ссылку.
// Параметры:
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла.
//  ИдентификаторФормы - уникальный идентификатор формы.
//
// Возвращаемое значение:
//   Строка - навигационная ссылка.
Функция ПолучитьНавигационнуюСсылкуВоВременномХранилище(ВерсияСсылка, ИдентификаторФормы = Неопределено) Экспорт
	Адрес = "";
	
	ТипХраненияФайла = ВерсияСсылка.ТипХраненияФайла;
	
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ ВерсияСсылка.Том.Пустая() Тогда
			ПолныйПуть = РаботаСФайламиСлужебный.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
				Адрес = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
			Исключение
				// Запись в журнал регистрации.
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(
					ИнформацияОбОшибке(), ВерсияСсылка.Владелец);
				
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Файлы.Открытие файла'",
					     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Ошибка,
					Метаданные.Справочники.Файлы,
					ВерсияСсылка.Владелец,
					СообщениеОбОшибке);
				
				ВызватьИсключение РаботаСФайламиСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ВерсияСсылка.ПолноеНаименование + "." + ВерсияСсылка.Расширение);
			КонецПопытки;
		КонецЕсли;
	Иначе
		ХранилищеФайла = РаботаСФайлами.ХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
		ДвоичныеДанные = ХранилищеФайла.Получить();
		Адрес = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
	КонецЕсли;
	
	Возврат Адрес;
	
КонецФункции

// Получает массив сертификатов шифрования.
// Параметры:
//  Ссылка  - СправочникСсылка.Файлы - файл.
//
// Возвращаемое значение:
//   Массив - массив структур
Функция СертификатыШифрования(Ссылка) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
		Возврат МодульЭлектроннаяПодпись.СертификатыШифрования(Ссылка);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Добавляет подпись к версии файла и отмечает файл, как подписанный.
Процедура ДобавитьПодписьКФайлу(ФайлСсылка, СвойстваПодписи, ИдентификаторФормы) Экспорт
	
	СтруктураРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ФайлСсылка, "Редактирует, Зашифрован");
	
	Редактирует = СтруктураРеквизитов.Редактирует;
	Если ЗначениеЗаполнено(Редактирует) Тогда
		ВызватьИсключение РаботаСФайламиСлужебныйКлиентСервер.СтрокаСообщенияОНедопустимостиПодписанияЗанятогоФайла(ФайлСсылка);
	КонецЕсли;
	
	Зашифрован = СтруктураРеквизитов.Зашифрован;
	Если Зашифрован Тогда
		СтрокаИсключения = РаботаСФайламиСлужебныйКлиентСервер.СтрокаСообщенияОНедопустимостиПодписанияЗашифрованногоФайла(ФайлСсылка);
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		Возврат;
	КонецЕсли;
	
	МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
	МодульЭлектроннаяПодпись.ДобавитьПодпись(ФайлСсылка, СвойстваПодписи, ИдентификаторФормы);
	
КонецПроцедуры

// Добавляет файл в тома при выполнении команды "разместить файлы начального образа".
// Параметры:
//  СоответствиеПутейФайлов - Соответствие - соответствие УникальногоИдентификатора файла и пути на диске к файлу.
//  ТипХраненияФайла - Перечисления.ТипыХраненияФайлов - тип хранения файлов.
Процедура ДобавитьФайлыВТомаПриРазмещении(СоответствиеПутейФайлов, ТипХраненияФайла) Экспорт
	
	Выборка = Справочники.ВерсииФайлов.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.ПолучитьОбъект();
		
		Если Объект.ТипХраненияФайла <> Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			Продолжить;
		КонецЕсли;
		
		УникальныйИдентификатор = Строка(Объект.Ссылка.УникальныйИдентификатор());
		
		ПолныйПутьФайлаНаДиске = СоответствиеПутейФайлов.Получить(УникальныйИдентификатор);
		ПолныйПутьНовый = "";
		
		Если ПолныйПутьФайлаНаДиске = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ХранилищеФайла = Неопределено;
		
		// В базе-приемнике файлы должны храниться в информационной базе - значит там их и разместим (даже если в исходной
		// базе они были в томах).
		Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			
			Объект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
			Объект.ПутьКФайлу = "";
			Объект.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
			
			ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПутьФайлаНаДиске);
			ХранилищеФайла = Новый ХранилищеЗначения(ДвоичныеДанные);
			
		Иначе // В базе-приемнике файлы должны храниться в томах на диске - переместим разархивированный файл на том.
			
			ФайлИсходный = Новый Файл(ПолныйПутьФайлаНаДиске);
			ПолныйПутьНовый = ФайлИсходный.Путь + Объект.Наименование + "." + Объект.Расширение;
			ПереместитьФайл(ПолныйПутьФайлаНаДиске, ПолныйПутьНовый);
			
			// Добавить в один из томов (где есть свободное место).
			СведенияОФайле = РаботаСФайламиСлужебный.ДобавитьФайлВТом(ПолныйПутьНовый, Объект.ДатаМодификацииУниверсальная,
				Объект.Наименование, Объект.Расширение, Объект.НомерВерсии, Объект.Владелец.Зашифрован); 
			Объект.Том = СведенияОФайле.Том;
			Объект.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
			
		КонецЕсли;
		
		Объект.ДополнительныеСвойства.Вставить("РазмещениеФайловВТомах", Истина); // Чтобы прошла запись подписанных файлов.
		Объект.Записать();
		
		Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			ЗаписатьФайлВИнформационнуюБазу(Объект.Ссылка, ХранилищеФайла);	
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ПолныйПутьНовый) Тогда
			УдалитьФайлы(ПолныйПутьНовый);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет регистрацию изменений - после размещения в томах.
// Параметры:
//  ПланОбменаСсылка - ПланОбмена.Ссылка - план обмена.
Процедура УдалитьРегистрациюИзменений(ПланОбменаСсылка) Экспорт
	
	ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.Справочники.ВерсииФайлов);
	ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.Справочники.Файлы);
	ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.РегистрыСведений.ДвоичныеДанныеФайлов);
	
КонецПроцедуры

// Получает полный путь к файлу на диске.
// Параметры:
//  ОбъектСсылка - СправочникСсылка.ВерсииФайлов,
//                 СправочникСсылка.*ПрисоединенныеФайлы.
//
// Возвращаемое значение:
//   Строка - полный путь к файлу на диске.
Функция ПолучитьИмяФайлаСПутемКДвоичнымДанным(ОбъектСсылка, ПустойПутьДляПустыхДанных = Ложь) Экспорт
	
	ПолноеИмяФайла = "";
	
	Если ОбъектСсылка.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		
		ХранилищеФайла = РаботаСФайлами.ХранилищеФайлаИзИнформационнойБазы(ОбъектСсылка);
		ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
		
		Если ПустойПутьДляПустыхДанных И ТипЗнч(ДвоичныеДанныеФайла) <> Тип("ДвоичныеДанные") Тогда
			Возврат "";
		КонецЕсли;
		
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла(ОбъектСсылка.Расширение);
		ДвоичныеДанныеФайла.Записать(ПолноеИмяФайла);
	Иначе
		Если НЕ ОбъектСсылка.Том.Пустая() Тогда
			ПолноеИмяФайла = РаботаСФайламиСлужебный.ПолныйПутьТома(ОбъектСсылка.Том) + ОбъектСсылка.ПутьКФайлу;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПолноеИмяФайла;
	
КонецФункции

// Извлечение текста

Функция ТекстЗапросаДляФайловСНеизвлеченнымТекстом(ИмяСправочника, ЧислоФайловВВыборке,
			ПолучитьВсеФайлы, ДополнительныеПоля)
	
	Если ДополнительныеПоля Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Файлы.Ссылка КАК Ссылка,
		|	ЕСТЬNULL(РегистрСведенийКодировкиФайлов.Кодировка, """") КАК Кодировка,
		|	Файлы.Расширение КАК Расширение,
		|	Файлы.Наименование КАК Наименование
		|ИЗ
		|	&ИмяСправочника КАК Файлы
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КодировкиФайлов КАК РегистрСведенийКодировкиФайлов
		|		ПО (РегистрСведенийКодировкиФайлов.Файл = Файлы.Ссылка)
		|ГДЕ
		|	Файлы.СтатусИзвлеченияТекста В (
		|		ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен),
		|		ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))";
	Иначе
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Файлы.Ссылка КАК Ссылка,
		|	ЕСТЬNULL(РегистрСведенийКодировкиФайлов.Кодировка, """") КАК Кодировка
		|ИЗ
		|	&ИмяСправочника КАК Файлы
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КодировкиФайлов КАК РегистрСведенийКодировкиФайлов
		|		ПО (РегистрСведенийКодировкиФайлов.Файл = Файлы.Ссылка)
		|ГДЕ
		|	Файлы.СтатусИзвлеченияТекста В (
		|		ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен),
		|		ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))";
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		Если ИмяСправочника = "ВерсииФайлов" Тогда
			ТекстЗапроса = ТекстЗапроса + "
				|	И НЕ Файлы.Владелец.Зашифрован";
		Иначе
			ТекстЗапроса = ТекстЗапроса + "
				|	И НЕ Файлы.Зашифрован";
		КонецЕсли;
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПЕРВЫЕ 1", ?(
		ПолучитьВсеФайлы,
		"",
		"ПЕРВЫЕ " + Формат(ЧислоФайловВВыборке, "ЧГ=; ЧН=")));
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяСправочника", "Справочник." + ИмяСправочника);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Записывает извлеченный текст.
//
// Параметры:
//  ТекущаяВерсия  - СправочникСсылка.ВерсииФайлов - версия файла.
//
Процедура ПриЗаписиИзвлеченногоТекста(ТекущаяВерсия) Экспорт
	
	ФайлЗаблокирован = Ложь;
	
	// Если это не версия, то записываем.
	Если ОбщегоНазначения.ЕстьРеквизитОбъекта("ВладелецФайла", Метаданные.НайтиПоТипу(ТипЗнч(ТекущаяВерсия))) Тогда
		ТекущаяВерсия.ОбменДанными.Загрузка = Истина;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ТекущаяВерсия);
		Возврат;
	КонецЕсли;
	
	Файл = ТекущаяВерсия.Владелец;
	Если Файл.ТекущаяВерсия = ТекущаяВерсия.Ссылка Тогда
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Файл);
			ФайлЗаблокирован = Истина;
		Исключение
			// Исключение, если объект уже заблокирован, в том числе и методом Заблокировать.
			Возврат;
		КонецПопытки;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		ТекущаяВерсия.ОбменДанными.Загрузка = Истина;
		ТекущаяВерсия.Записать();
		
		Если Файл.ТекущаяВерсия = ТекущаяВерсия.Ссылка Тогда
			БлокировкаДанных = Новый БлокировкаДанных;
			ЭлементБлокировкиДанных = БлокировкаДанных.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(Файл)).ПолноеИмя());
			ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", Файл);
			БлокировкаДанных.Заблокировать();
			ФайлОбъект = Файл.ПолучитьОбъект();
			ФайлОбъект.ТекстХранилище = ТекущаяВерсия.ТекстХранилище;
			ФайлОбъект.ОбменДанными.Загрузка = Истина;
			ФайлОбъект.Записать();
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		
		Если ФайлЗаблокирован Тогда
			РазблокироватьДанныеДляРедактирования(Файл);
		КонецЕсли;
		
		ВызватьИсключение;
	КонецПопытки;
	
	Если ФайлЗаблокирован Тогда
		РазблокироватьДанныеДляРедактирования(Файл);
	КонецЕсли;
	
КонецПроцедуры

// Настройки 

// Считаем из настроек СпособСравненияВерсийФайлов.
//
// Возвращаемое значение:
//   Строка - Способ сравнения версий файлов.
//
Функция СпособСравненияВерсийФайлов()
	
	СпособСравнения = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить(
		"НастройкиСравненияФайлов", "СпособСравненияВерсийФайлов");
	
	Если СпособСравнения = Перечисления.СпособыСравненияВерсийФайлов.MicrosoftOfficeWord Тогда
		Возврат "MicrosoftOfficeWord";
		
	ИначеЕсли СпособСравнения = Перечисления.СпособыСравненияВерсийФайлов.OpenOfficeOrgWriter Тогда
		Возврат "OpenOfficeOrgWriter";
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Информационные

// Функция возвращает количество Файлов, занятых текущим пользователем
// в разрезе владельца.
// Параметры:
//  ВладелецФайла  - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   Число  - количество занятых файлов.
//
Функция КоличествоФайловЗанятыхТекущимПользователем(ВладелецФайла) Экспорт
	
	Возврат РаботаСФайламиСлужебный.КоличествоЗанятыхФайлов(ВладелецФайла);
	
КонецФункции

// Получает значение настройки  ПоказыватьКолонкуРазмер.
// Возвращаемое значение:
//   Булево - Показывать колонку размер.
//
Функция ПолучитьПоказыватьКолонкуРазмер() Экспорт
	ПоказыватьКолонкуРазмер = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПрограммы", "ПоказыватьКолонкуРазмер");
	Если ПоказыватьКолонкуРазмер = Неопределено Тогда
		ПоказыватьКолонкуРазмер = Ложь;
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиПрограммы", "ПоказыватьКолонкуРазмер", ПоказыватьКолонкуРазмер);
	КонецЕсли;
	
	Возврат ПоказыватьКолонкуРазмер;
	
КонецФункции

// Возвращает количество файлов в томах.
// Возвращаемое значение:
//   Число - число файлов в томах.
//
Функция ПодсчитатьКоличествоФайловВТомах()
	
	Запрос = Новый Запрос;
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ЕСТЬNULL(КОЛИЧЕСТВО(Версии.Ссылка), 0) КАК КоличествоФайлов
	|ИЗ
	|	Справочник.ВерсииФайлов КАК Версии
	|ГДЕ
	|	Версии.ТипХраненияФайла = ЗНАЧЕНИЕ(Перечисление.ТипыХраненияФайлов.ВТомахНаДиске)";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Число(Выборка.КоличествоФайлов);
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Получает количество версий файла.
// Параметры:
//  ФайлСсылка - СправочникСсылка.Файлы - файл.
//
// Возвращаемое значение:
//   Число - число версий
Функция ПолучитьКоличествоВерсий(ФайлСсылка)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	Справочник.ВерсииФайлов КАК ВерсииФайлов
	|ГДЕ
	|	ВерсииФайлов.Владелец = &ФайлСсылка";
	
	Запрос.УстановитьПараметр("ФайлСсылка", ФайлСсылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Число(Выборка.Количество);
	
КонецФункции

// Вернет Истина если есть зацикливание (если одну из папок переносим в ее же дочернюю папку).
// Параметры:
//  МассивСсылокНаФайлы - Массив - массив файлов.
//  НовыйРодитель  - ЛюбаяСсылка - новый владелец файла.
//
// Возвращаемое значение:
//   Булево  - есть зацикливание.
//
Функция ЕстьЗацикливание(Знач МассивСсылокНаФайлы, НовыйРодитель)
	
	Если МассивСсылокНаФайлы.Найти(НовыйРодитель) <> Неопределено Тогда
		Возврат Истина; // нашли зацикливание
	КонецЕсли;
	
	Родитель = НовыйРодитель.Родитель;
	Если Родитель.Пустая() Тогда // дошли до корня
		Возврат Ложь;
	КонецЕсли;
	
	Если ЕстьЗацикливание(МассивСсылокНаФайлы, Родитель) Тогда
		Возврат Истина; // нашли зацикливание
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Возвращает Истина, если в указанном элементе справочника ПапкиФайлов есть дочерний элемент с таким именем.
//
// Параметры:
//  ИмяПапки					 - Строка					     - имя папки
//  Родитель					 - ОпределяемыйТип.ВладелецПрисоединенныхФайлов	 - родитель папки.
//  ПерваяПапкаСТакимЖеИменем	 - ОпределяемыйТип.ВладелецПрисоединенныхФайлов	 - первая же найденная папка с указанным именем.
// 
// Возвращаемое значение:
//  Булево - есть дочерний элемент с таким именем.
//
Функция ЕстьПапкаСТакимИменем(ИмяПапки, Родитель, ПерваяПапкаСТакимЖеИменем) Экспорт
	
	ПерваяПапкаСТакимЖеИменем = Справочники.ПапкиФайлов.ПустаяСсылка();
	
	ЗапросВПапки = Новый Запрос;
	ЗапросВПапки.УстановитьПараметр("Наименование", ИмяПапки);
	ЗапросВПапки.УстановитьПараметр("Родитель", Родитель);
	ЗапросВПапки.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ПапкиФайлов.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПапкиФайлов КАК ПапкиФайлов
	|ГДЕ
	|	ПапкиФайлов.Наименование = &Наименование
	|	И ПапкиФайлов.Родитель = &Родитель";
	
	Если ТипЗнч(Родитель) <> Тип("СправочникСсылка.ПапкиФайлов") Тогда
		ИмяСправочникаХранилищаФайлов = РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(Родитель);
		ЗапросВПапки.Текст = СтрЗаменить(ЗапросВПапки.Текст, ".ПапкиФайлов", "." + ИмяСправочникаХранилищаФайлов);
	КонецЕсли;
	
	РезультатЗапроса = ЗапросВПапки.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаЗапроса = РезультатЗапроса.Выгрузить();
		ПерваяПапкаСТакимЖеИменем = ВыборкаЗапроса[0].Ссылка;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ПолныйПутьПапки(Папка)
	
	ПолныйПуть = "";
	
	ПапкаРодитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Папка.Ссылка, "Родитель");
	
	Если ЗначениеЗаполнено(ПапкаРодитель) Тогда
	
		ПолныйПуть = "";
		Пока ЗначениеЗаполнено(ПапкаРодитель) Цикл
			
			ПолныйПуть = Строка(ПапкаРодитель) + "\" + ПолныйПуть;
			ПапкаРодитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ПапкаРодитель, "Родитель");
			Если Не ЗначениеЗаполнено(ПапкаРодитель) Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		ПолныйПуть = ПолныйПуть + Строка(Папка.Ссылка);
		
		Если Не ПустаяСтрока(ПолныйПуть) Тогда
			ПолныйПуть = """" + ПолныйПуть + """";
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат ПолныйПуть;
	
КонецФункции

// Возвращает в параметре КоличествоФайловВТомах количество файлов в томах.
Процедура ОпределитьКоличествоФайловВТомах(КоличествоФайловВТомах) Экспорт
	
	КоличествоФайловВТомах = КоличествоФайловВТомах + ПодсчитатьКоличествоФайловВТомах();
	
КонецПроцедуры

// Есть ли дублирующийся элемент в условном оформлении списка.
// Параметры:
// Элементы - массив элементов условного оформления списка.
// ЭлементПоиска - элемент условного оформления списка.
//
// Возвращаемое значение:
//   Булево - есть дублирующийся элемент.
//
Функция ЕстьДублирующийсяЭлемент(Элементы, ЭлементПоиска)
	
	Для Каждого Элемент Из Элементы Цикл
		Если Элемент <> ЭлементПоиска Тогда
			
			Если Элемент.Оформление.Элементы.Количество() <> ЭлементПоиска.Оформление.Элементы.Количество() Тогда
				Продолжить;
			КонецЕсли;
			
			НайденОтличающийсяЭлемент = Ложь;
			
			// Обходим все элементы оформления - если есть хоть один отличающийся - делаем Продолжить;
			ЧислоЭлементов = Элемент.Оформление.Элементы.Количество();
			Для Индекс = 0 По ЧислоЭлементов - 1 Цикл
				Элемент1 = Элемент.Оформление.Элементы[Индекс];
				Элемент2 = ЭлементПоиска.Оформление.Элементы[Индекс];
				
				Если Элемент1.Использование И Элемент2.Использование Тогда
					Если Элемент1.Параметр <> Элемент2.Параметр ИЛИ Элемент1.Значение <> Элемент2.Значение Тогда
						НайденОтличающийсяЭлемент = Истина;
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			Если НайденОтличающийсяЭлемент Тогда
				Продолжить;
			КонецЕсли;
			
			Если Элемент.Отбор.Элементы.Количество() <> ЭлементПоиска.Отбор.Элементы.Количество() Тогда
				Продолжить;
			КонецЕсли;
			
			// Обходим все элементы отбора - если есть хоть один отличающийся - делаем Продолжить;
			ЧислоЭлементов = Элемент.Отбор.Элементы.Количество();
			Для Индекс = 0 По ЧислоЭлементов - 1 Цикл
				Элемент1 = Элемент.Отбор.Элементы[Индекс];
				Элемент2 = ЭлементПоиска.Отбор.Элементы[Индекс];
				
				Если Элемент1.Использование И Элемент2.Использование Тогда
					Если Элемент1.ВидСравнения <> Элемент2.ВидСравнения
						ИЛИ Элемент1.ЛевоеЗначение <> Элемент2.ЛевоеЗначение
						ИЛИ Элемент1.ПравоеЗначение <> Элемент2.ПравоеЗначение Тогда
						
						НайденОтличающийсяЭлемент = Истина;
						Прервать;
						
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			Если НайденОтличающийсяЭлемент Тогда
				Продолжить;
			КонецЕсли;
			
			// Обошли все элементы оформления и отбора - они все одинаковы - это дубль.
			Возврат Истина;
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ФайлСинхронизируетсяОблачнымСервисом(Файл)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	КОЛИЧЕСТВО(СтатусыСинхронизацииФайловСОблачнымСервисом.Файл) КАК Файл
		|ИЗ
		|	РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
		|ГДЕ
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл = &Файл";
	
	Запрос.УстановитьПараметр("Файл", Файл);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ

// В справочнике ВерсииФайлов из данных в Код(Строка) заполняет НомерВерсии(Число).
Процедура ЗаполнитьНомерВерсииИзКодаСправочника() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВерсииФайлов.Ссылка,
	|	ВерсииФайлов.ПометкаУдаления,
	|	ВерсииФайлов.Код,
	|	ВерсииФайлов.НомерВерсии,
	|	ВерсииФайлов.Владелец.ПометкаУдаления КАК ВладелецПометкаУдаления,
	|	ВерсииФайлов.Владелец.ТекущаяВерсия
	|ИЗ
	|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Если Выборка.НомерВерсии = 0 Тогда 
			
			ОписаниеТипов = Новый ОписаниеТипов("Число");
			КодЧисло = ОписаниеТипов.ПривестиЗначение(Выборка.Код);
			Если КодЧисло <> 0 Тогда
				Объект = Выборка.Ссылка.ПолучитьОбъект();
				Объект.НомерВерсии = КодЧисло;
				
				// Коррекция ситуации, допустимой ранее, но недопустимой сейчас - активная версия помечена на удаление, а владелец
				// - нет.
				Если Выборка.ПометкаУдаления = Истина И Выборка.ВладелецПометкаУдаления = Ложь И Выборка.ТекущаяВерсия = Выборка.Ссылка Тогда
					Объект.ПометкаУдаления = Ложь;
				КонецЕсли;
				
				ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
			КонецЕсли
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// В справочнике ВерсииФайлов заполняет ТипХраненияФайла значением ВБазе.
Процедура ЗаполнитьТипХраненияФайлаВБазе() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВерсииФайлов.Ссылка
	|ИЗ
	|	Справочник.ВерсииФайлов КАК ВерсииФайлов";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Если Объект.ТипХраненияФайла.Пустая() Тогда
			Объект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// В справочнике ВерсииФайлов и Файлы ИндексКартинки увеличивает в 2 раза.
Процедура СменитьИндексПиктограммы() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВерсииФайлов.Ссылка
	|ИЗ
	|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ОбменДанными.Загрузка = Истина;
		Объект.ИндексКартинки = РаботаСФайламиСлужебныйКлиентСервер.ПолучитьИндексПиктограммыФайла(Объект.Расширение);
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Файлы.Ссылка
	|ИЗ
	|	Справочник.Файлы КАК Файлы";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ОбменДанными.Загрузка = Истина;
		Объект.ИндексКартинки = Объект.ТекущаяВерсия.ИндексКартинки;
		Объект.Записать();
	КонецЦикла;
	
КонецПроцедуры

// Вызывается при обновлении на 1.0.6.3 - заполняет пути ТомаХраненияФайлов.
Процедура ЗаполнитьПутиТома() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТомаХраненияФайлов.Ссылка
	|ИЗ
	|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ПолныйПутьLinux = Объект.ПолныйПутьWindows;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
	КонецЦикла;
	
КонецПроцедуры

// В справочнике Файлы перезаписывает все элементы.
Процедура ПерезаписатьВсеФайлы() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Файлы.Ссылка
	|ИЗ
	|	Справочник.Файлы КАК Файлы";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.Записать();
	КонецЦикла;
	
КонецПроцедуры

// В справочнике ВерсииФайлов заполняет ДатаМодификацииФайла - из даты создания.
Процедура ЗаполнитьДатуМодификацииФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Если Объект.ДатаМодификацииФайла = Дата("00010101000000") Тогда
			Объект.ДатаМодификацииФайла = Объект.ДатаСоздания;
			Объект.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
	ПерезаписатьВсеФайлы(); // Чтобы перенеслись значения реквизита ДатаМодификацииФайла из версии в файл.
	
КонецПроцедуры

// Создает новые файлы по аналогии с указанными.
// Параметры:
//  МассивФайлов  - Массив - массив объектов СправочникСсылка.Файлы - существующие файлы.
//  ВладелецНовогоФайла - ЛюбаяСсылка - владелец файла.
//
Процедура СкопироватьФайлы(МассивФайлов, ВладелецНовогоФайла) Экспорт
	
	Для каждого Файл Из МассивФайлов Цикл
		НовыйФайл = СкопироватьФайл(Файл, ВладелецНовогоФайла);
	КонецЦикла;
	
КонецПроцедуры

// Записывает ХранилищеФайла в информационную базу.
//
// Параметры:
// ВерсияСсылка - ссылка на версию файла.
// ХранилищеФайла - ХранилищеЗначения, с двоичными данными файла, которые требуется записать.
//
Процедура ЗаписатьФайлВИнформационнуюБазу(ВерсияСсылка, ХранилищеФайла)
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.ДвоичныеДанныеФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Файл = ВерсияСсылка;
	МенеджерЗаписи.ДвоичныеДанныеФайла = ХранилищеФайла;
	МенеджерЗаписи.Записать(Истина);
	
КонецПроцедуры

// Удаляет запись в регистре ХранимыеФайлыВерсий.
//
// Параметры:
// Файл - ссылка на файл.
//
Процедура УдалитьЗаписьИзРегистраДвоичныеДанныеФайлов(Файл) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ДвоичныеДанныеФайлов.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Файл.Установить(Файл);
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Переносит бинарный файл из ФайлХранилище справочника ВерсииФайлов в регистр сведений ХранимыеФайлыВерсий.
Процедура ПереместитьФайлыИзИнформационнойБазыВРегистрСведений() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВерсииФайлов.Ссылка
	|ИЗ
	|	Справочник.ВерсииФайлов КАК ВерсииФайлов
	|ГДЕ
	|	ВерсииФайлов.ТипХраненияФайла = &ТипХраненияФайла";
		
	Запрос.УстановитьПараметр("ТипХраненияФайла", Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе);	

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		ДанныеВХранилище = Объект.ФайлХранилище.Получить();
		Если ТипЗнч(ДанныеВХранилище) = Тип("ДвоичныеДанные") Тогда
			ЗаписатьФайлВИнформационнуюБазу(Выборка.Ссылка, Объект.ФайлХранилище);
			Объект.ФайлХранилище = Новый ХранилищеЗначения(""); // очищаем значение
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет поле ДатаЗаема текущей датой.
Процедура ЗаполнитьДатуЗаема() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДатаЗаема = ТекущаяДатаСеанса();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ЗначениеЗаполнено(Выборка.Ссылка.Редактирует) Тогда
			Объект = Выборка.Ссылка.ПолучитьОбъект();
			// Чтобы прошла запись ранее подписанного объекта.
			Объект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
			Объект.ДатаЗаема = ДатаЗаема;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Переименовывает старые права в новые.
Процедура ЗаменитьПраваВНастройкахПравПапокФайлов() Экспорт
	
	Если НЕ ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
		Возврат;
	КонецЕсли;
	
	МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
	
	ТаблицаЗамены = МодульУправлениеДоступом.ТаблицаЗаменыПравВНастройкахПравОбъектов();
	
	Строка = ТаблицаЗамены.Добавить();
	Строка.ТипВладельцев = Справочники.ПапкиФайлов.ПустаяСсылка();
	Строка.СтароеИмя = "ЧтениеПапокИФайлов";
	Строка.НовоеИмя  = "Чтение";
	
	Строка = ТаблицаЗамены.Добавить();
	Строка.ТипВладельцев = Справочники.ПапкиФайлов.ПустаяСсылка();
	Строка.СтароеИмя = "ДобавлениеПапокИФайлов";
	Строка.НовоеИмя  = "ДобавлениеФайлов";
	
	Строка = ТаблицаЗамены.Добавить();
	Строка.ТипВладельцев = Справочники.ПапкиФайлов.ПустаяСсылка();
	Строка.СтароеИмя = "ИзменениеПапокИФайлов";
	Строка.НовоеИмя  = "ИзменениеФайлов";
	
	Строка = ТаблицаЗамены.Добавить();
	Строка.ТипВладельцев = Справочники.ПапкиФайлов.ПустаяСсылка();
	Строка.СтароеИмя = "ИзменениеПапокИФайлов";
	Строка.НовоеИмя  = "ИзменениеПапок";
	
	Строка = ТаблицаЗамены.Добавить();
	Строка.ТипВладельцев = Справочники.ПапкиФайлов.ПустаяСсылка();
	Строка.СтароеИмя = "ПометкаУдаленияПапокИФайлов";
	Строка.НовоеИмя  = "ПометкаУдаленияФайлов";
	
	МодульУправлениеДоступом.ЗаменитьПраваВНастройкахПравОбъектов(ТаблицаЗамены);
	
КонецПроцедуры

// Ставит файлу признак Зашифрован.
Процедура УстановитьПризнакЗашифрован(ФайлСсылка, Зашифрован, УникальныйИдентификатор = Неопределено) Экспорт
	
	НачатьТранзакцию();
	Попытка
		БлокировкаДанных = Новый БлокировкаДанных;
		ЭлементБлокировкиДанных = БлокировкаДанных.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ФайлСсылка)).ПолноеИмя());
		ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", ФайлСсылка);
		БлокировкаДанных.Заблокировать();
		
		ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
		
		ФайлОбъект.Зашифрован = Зашифрован;
		// Чтобы прошла запись ранее подписанного объекта.
		ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет размер файла и текущей версии. Нужно при загрузке шифрованного файла в почте.
Процедура ОбновитьРазмерФайлаИВерсии(ДанныеФайла, РазмерФайла, УникальныйИдентификатор) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		ВерсияОбъект = ДанныеФайла.Версия.ПолучитьОбъект();
		ВерсияОбъект.Заблокировать();
		ВерсияОбъект.Размер = РазмерФайла;
		// Чтобы прошла запись ранее подписанного объекта.
		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
		ВерсияОбъект.Записать();
		ВерсияОбъект.Разблокировать();
		
		ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
		// Чтобы прошла запись ранее подписанного объекта.
		ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Получает количество версий с неизвлеченным текстом.
Процедура ПолучитьКоличествоВерсийСНеизвлеченнымТекстом(ДополнительныеПараметры, АдресВоВременномХранилище) Экспорт
	
	КоличествоФайлов = 0;
	
	ТипыФайлов = Метаданные.ОпределяемыеТипы.ПрисоединенныйФайл.Тип.Типы();
	
	Для Каждого Тип Из ТипыФайлов Цикл
		
		МетаданныеСправочникаФайлов = Метаданные.НайтиПоТипу(Тип);
		
		Запрос = Новый Запрос;
		
		ТекстЗапроса = 
			"ВЫБРАТЬ
			|	ЕСТЬNULL(КОЛИЧЕСТВО(Файлы.Ссылка), 0) КАК КоличествоФайлов
			|ИЗ
			|	&ИмяСправочника КАК Файлы
			|ГДЕ
			|	Файлы.СтатусИзвлеченияТекста В (ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен), ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))";
	
		Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
			Если Тип = Тип("СправочникСсылка.ВерсииФайлов") Тогда
				ТекстЗапроса = ТекстЗапроса + "
					|	И НЕ Файлы.Владелец.Зашифрован";
			Иначе
				ТекстЗапроса = ТекстЗапроса + "
					|	И НЕ Файлы.Зашифрован";
			КонецЕсли;
		КонецЕсли;
	
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяСправочника", "Справочник." + МетаданныеСправочникаФайлов.Имя);
		Запрос.Текст = ТекстЗапроса;
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			КоличествоФайлов = КоличествоФайлов + Выборка.КоличествоФайлов;
		КонецЕсли
		
	КонецЦикла;
	
	ПоместитьВоВременноеХранилище(КоличествоФайлов, АдресВоВременномХранилище);
	
КонецПроцедуры

// Записывает кодировку версии файла.
//
// Параметры:
// ВерсияСсылка - СправочникСсылка.ВерсииФайлов - ссылка на версию файла.
// Кодировка - Строка - новая кодировка версии файла.
//
Процедура ЗаписатьКодировкуВерсииФайла(ВерсияСсылка, Кодировка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.КодировкиФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Файл = ВерсияСсылка;
	МенеджерЗаписи.Кодировка = Кодировка;
	МенеджерЗаписи.Записать(Истина);
	
КонецПроцедуры

// Записывает кодировку версии файла.
//
// Параметры:
// ВерсияСсылка - ссылка на версию файла.
// Кодировка - Строка кодировки.
// ИзвлеченныйТекст - текст, извлеченный из файла.
//
Процедура ЗаписатьКодировкуВерсииФайлаИИзвлеченныйТекст(ВерсияСсылка, Кодировка, ИзвлеченныйТекст) Экспорт
	
	ЗаписатьКодировкуВерсииФайла(ВерсияСсылка, Кодировка);
	ЗаписатьРезультатИзвлеченияТекстаПриРедактировании(ВерсияСсылка, Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен, 
		ИзвлеченныйТекст);
	
КонецПроцедуры

// Записывает на сервер результат извлечения текста - извлеченный текст и СтатусИзвлеченияТекста.
Процедура ЗаписатьРезультатИзвлеченияТекстаПриРедактировании(ВерсияСсылка, РезультатИзвлечения, АдресВременногоХранилищаТекста)
	
	ФайлЗаблокирован = Ложь;
	
	МетаданныеВерсии = Метаданные.НайтиПоТипу(ТипЗнч(ВерсияСсылка));
	Если ОбщегоНазначения.ЕстьРеквизитОбъекта("РодительскаяВерсия", МетаданныеВерсии) Тогда
		Файл = ВерсияСсылка.Владелец;
		
		Если Файл.ТекущаяВерсия = ВерсияСсылка Тогда
			
			Попытка
				ЗаблокироватьДанныеДляРедактирования(Файл);
				ФайлЗаблокирован = Истина;
			Исключение
				// Исключение, если объект уже заблокирован, в том числе и методом Заблокировать.
				Возврат;
			КонецПопытки;
			
		КонецЕсли;
	Иначе
		Файл = ВерсияСсылка;
	КонецЕсли;
	
	Текст = "";
	НачатьТранзакцию();
	
	Попытка
		БлокировкаВерсии = Новый БлокировкаДанных;
		ЭлементБлокировкиДанных = БлокировкаВерсии.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(ВерсияСсылка)).ПолноеИмя());
		ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", ВерсияСсылка);
		БлокировкаВерсии.Заблокировать();
		
		ВерсияОбъект = ВерсияСсылка.ПолучитьОбъект();
		
		Если Не ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
			
			Если ЭтоАдресВременногоХранилища(АдресВременногоХранилищаТекста) Тогда
				Текст = РаботаСФайламиСлужебный.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
			Иначе	
				Текст = АдресВременногоХранилищаТекста;
			КонецЕсли;
			
			ВерсияОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
			ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
			
		КонецЕсли;
		
		Если РезультатИзвлечения = "НеИзвлечен" Тогда
			ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
		ИначеЕсли РезультатИзвлечения = "Извлечен" Тогда
			ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		ИначеЕсли РезультатИзвлечения = "ИзвлечьНеУдалось" Тогда
			ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
		КонецЕсли;
	
		// Чтобы прошла запись ранее подписанного объекта.
		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
		ВерсияОбъект.Записать();
		
		Если Файл.ТекущаяВерсия = ВерсияСсылка Тогда
			БлокировкаФайла = Новый БлокировкаДанных;
			ЭлементБлокировкиДанных = БлокировкаФайла.Добавить(Метаданные.НайтиПоТипу(ТипЗнч(Файл)).ПолноеИмя());
			ЭлементБлокировкиДанных.УстановитьЗначение("Ссылка", Файл);
			БлокировкаФайла.Заблокировать();
			
			ФайлОбъект = Файл.ПолучитьОбъект();
			ФайлОбъект.ТекстХранилище = ВерсияОбъект.ТекстХранилище;
			// Чтобы прошла запись ранее подписанного объекта.
			ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
			ФайлОбъект.Записать();
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		
		Если ФайлЗаблокирован Тогда
			РазблокироватьДанныеДляРедактирования(Файл);
		КонецЕсли;
		
		ВызватьИсключение;
	КонецПопытки;
	
	Если ФайлЗаблокирован Тогда
		РазблокироватьДанныеДляРедактирования(Файл);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗарегистрироватьОбъектыДляПереносаЭлектронныхПодписейСВерсийФайловНаФайлы(Параметры) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ЭлектронныеПодписи.ПодписанныйОбъект КАК Ссылка
	|ИЗ
	|	РегистрСведенийЭлектронныеПодписи КАК ЭлектронныеПодписи
	|ГДЕ
	|	ТИПЗНАЧЕНИЯ(ЭлектронныеПодписи.ПодписанныйОбъект) = ТИП(Справочник.ВерсииФайлов)";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,
		"РегистрСведенийЭлектронныеПодписи", "РегистрСведений." + "ЭлектронныеПодписи");
	
	МассивСсылок = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
	ОбновлениеИнформационнойБазы.ОтметитьКОбработке(Параметры, МассивСсылок);
	
КонецПроцедуры

Процедура ПеренестиЭлектронныеПодписиСВерсийФайловНаФайлы(Параметры) Экспорт
	
	ОбработкаЗавершена = Истина;
	
	ВыборкаСсылок = ОбновлениеИнформационнойБазы.ВыбратьСсылкиДляОбработки(Параметры.Очередь, "Справочник.ВерсииФайлов");
	
	ОбъектовОбработано = 0;
	ПроблемныхОбъектов = 0;
	
	МассивСсылок = Новый Массив;
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировкиПоВерсии = Блокировка.Добавить("РегистрСведений." + "ЭлектронныеПодписи");
	ЭлементБлокировкиПоФайлу  = Блокировка.Добавить("РегистрСведений." + "ЭлектронныеПодписи");
	
	Пока ВыборкаСсылок.Следующий() Цикл
		ВерсияСсылка = ВыборкаСсылок.Ссылка;
		ЭлементБлокировкиПоВерсии.УстановитьЗначение("ПодписанныйОбъект", ВерсияСсылка);
		ФайлСсылка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ВерсияСсылка, "Владелец");
		Если ЗначениеЗаполнено(ФайлСсылка) Тогда
			ЭлементБлокировкиПоВерсии.УстановитьЗначение("ПодписанныйОбъект", ФайлСсылка);
		КонецЕсли;
		НачатьТранзакцию();
		Попытка
			Блокировка.Заблокировать();
			
			НаборЗаписейПоВерсии = РегистрыСведений["ЭлектронныеПодписи"].СоздатьНаборЗаписей();
			НаборЗаписейПоВерсии.Отбор.ПодписанныйОбъект.Установить(ВерсияСсылка);
			НаборЗаписейПоВерсии.Прочитать();
			
			Если НаборЗаписейПоВерсии.Количество() > 0 Тогда
				Если ЗначениеЗаполнено(ФайлСсылка) Тогда
					НаборЗаписейПоФайлу = РегистрыСведений["ЭлектронныеПодписи"].СоздатьНаборЗаписей();
					НаборЗаписейПоФайлу.Отбор.ПодписанныйОбъект.Установить(ФайлСсылка);
					НаборЗаписейПоФайлу.Прочитать();
					Если НаборЗаписейПоФайлу.Количество() = 0 Тогда
						Для Каждого Запись Из НаборЗаписейПоВерсии Цикл
							НоваяЗапись = НаборЗаписейПоФайлу.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяЗапись, Запись);
							НоваяЗапись.ПодписанныйОбъект = ФайлСсылка;
						КонецЦикла;
						НаборЗаписейПоФайлу.Записать();
					КонецЕсли;
				КонецЕсли;
				НаборЗаписейПоВерсии.Очистить();
				НаборЗаписейПоВерсии.Записать();
			КонецЕсли;
			
			ОбновлениеИнформационнойБазы.ОтметитьВыполнениеОбработки(ВерсияСсылка);
			ОбъектовОбработано = ОбъектовОбработано + 1;
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			// Если не удалось обработать какой-либо объект, требуется повторить попытку.
			ОбъектовОбработано = ОбъектовОбработано - 1;
			ПроблемныхОбъектов = ПроблемныхОбъектов + 1;
			
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось обработать версию файла ""%1"" по причине:
				           |%2'"),
				ВерсияСсылка,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
			ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
				УровеньЖурналаРегистрации.Предупреждение, Метаданные.Справочники.ВерсииФайлов, ВерсияСсылка, ТекстСообщения);
		КонецПопытки;
	КонецЦикла;
	
	Если Не ОбновлениеИнформационнойБазы.ОбработкаДанныхЗавершена(Параметры.Очередь, "Справочник.ВерсииФайлов") Тогда
		ОбработкаЗавершена = Ложь;
	КонецЕсли;
	
	Если ОбъектовОбработано = 0 И ПроблемныхОбъектов <> 0 Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Процедуре ПеренестиЭлектронныеПодписиСВерсийФайловНаФайлы не удалось обработать некоторые версии файлов (пропущены): %1'"),
			ПроблемныхОбъектов);
		ВызватьИсключение ТекстСообщения;
	Иначе
		ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Информация,
			Метаданные.Справочники.ВерсииФайлов,
			,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Процедура ПеренестиЭлектронныеПодписиСВерсийФайловНаФайлы обработала очередную порцию версий файлов: %1'"),
				ОбъектовОбработано));
	КонецЕсли;
	
	Параметры.ОбработкаЗавершена = ОбработкаЗавершена;
	
КонецПроцедуры

Функция ОбъектыПриПереносеЭлектронныхПодписейСВерсийФайловНаФайлы(Читаемые) Экспорт
	
	Если Читаемые Тогда
		Возврат "Справочник.ВерсииФайлов, "
		      + Метаданные.РегистрыСведений["ЭлектронныеПодписи"].ПолноеИмя();
	Иначе
		Возврат Метаданные.РегистрыСведений["ЭлектронныеПодписи"].ПолноеИмя();
	КонецЕсли;
	
КонецФункции

// Регистрирует на плане обмена ОбновлениеИнформационнойБазы объекты,
// для которых необходимо обновить записи в реестре.
//
Процедура ЗарегистрироватьОбъектыДляПереносаЭлектронныхПодписейИСертификатовШифрования(Параметры) Экспорт
	
	ТекстЗапросаДвеТабличныеЧасти =
	"ВЫБРАТЬ
	|	Файлы.Ссылка КАК Ссылка
	|ИЗ
	|	ТаблицаОбъектов КАК Файлы
	|ГДЕ
	|	(ИСТИНА В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ИСТИНА
	|				ИЗ
	|					ТабличнаяЧастьУдалитьСертификатыШифрования КАК УдалитьСертификатыШифрования
	|				ГДЕ
	|					УдалитьСертификатыШифрования.Ссылка = Файлы.Ссылка)
	|			ИЛИ ИСТИНА В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ИСТИНА
	|				ИЗ
	|					ТабличнаяЧастьУдалитьЭлектронныеПодписи КАК УдалитьЭлектронныеПодписи
	|				ГДЕ
	|					УдалитьЭлектронныеПодписи.Ссылка = Файлы.Ссылка))";
	
	ТекстЗапросаТЧУдалитьСертификатыШифрования =
	"ВЫБРАТЬ
	|	Файлы.Ссылка КАК Ссылка
	|ИЗ
	|	ТаблицаОбъектов КАК Файлы
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				ТабличнаяЧастьУдалитьСертификатыШифрования КАК УдалитьСертификатыШифрования
	|			ГДЕ
	|				УдалитьСертификатыШифрования.Ссылка = Файлы.Ссылка)";
	
	ТекстЗапросаТЧУдалитьЭлектронныеПодписи =
	"ВЫБРАТЬ
	|	Файлы.Ссылка КАК Ссылка
	|ИЗ
	|	ТаблицаОбъектов КАК Файлы
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				ТабличнаяЧастьУдалитьЭлектронныеПодписи КАК УдалитьЭлектронныеПодписи
	|			ГДЕ
	|				УдалитьЭлектронныеПодписи.Ссылка = Файлы.Ссылка)";
	
	Запрос = Новый Запрос;
	ПолныеИменаСправочников = ПолныеИменаСправочниковПрисоединенныхФайлов();
	
	Для Каждого ПолноеИмя Из ПолныеИменаСправочников Цикл
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
		
		ЕстьТЧУдалитьСертификатыШифрования =
			ОбъектМетаданных.ТабличныеЧасти.Найти("УдалитьСертификатыШифрования") <> Неопределено;
		
		ЕстьТЧУдалитьЭлектронныеПодписи =
			ОбъектМетаданных.ТабличныеЧасти.Найти("УдалитьЭлектронныеПодписи") <> Неопределено;
		
		Если ЕстьТЧУдалитьСертификатыШифрования И ЕстьТЧУдалитьЭлектронныеПодписи Тогда
			ТекущийТекстЗапроса = ТекстЗапросаДвеТабличныеЧасти;
			
		ИначеЕсли ЕстьТЧУдалитьСертификатыШифрования Тогда
			ТекущийТекстЗапроса = ТекстЗапросаТЧУдалитьСертификатыШифрования;
			
		ИначеЕсли ЕстьТЧУдалитьЭлектронныеПодписи Тогда
			ТекущийТекстЗапроса = ТекстЗапросаТЧУдалитьЭлектронныеПодписи;
		Иначе 
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Запрос.Текст) Тогда
			Запрос.Текст = Запрос.Текст + "
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|
			|";
		КонецЕсли;
		
		ТекущийТекстЗапроса = СтрЗаменить(ТекущийТекстЗапроса, "ТаблицаОбъектов", ПолноеИмя);
		
		ТекущийТекстЗапроса = СтрЗаменить(ТекущийТекстЗапроса,
			"ТабличнаяЧастьУдалитьСертификатыШифрования", ПолноеИмя + ".УдалитьСертификатыШифрования");
		
		ТекущийТекстЗапроса = СтрЗаменить(ТекущийТекстЗапроса,
			"ТабличнаяЧастьУдалитьЭлектронныеПодписи", ПолноеИмя + ".УдалитьЭлектронныеПодписи");
		
		Запрос.Текст = Запрос.Текст + ТекущийТекстЗапроса;
	КонецЦикла;
	
	МассивСсылок = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка"); 
	
	ОбновлениеИнформационнойБазы.ОтметитьКОбработке(Параметры, МассивСсылок);
	
КонецПроцедуры

Процедура ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведений(Параметры) Экспорт
	
	ОбработкаЗавершена = Истина;
	
	ПолныеИменаСправочников = ПолныеИменаСправочниковПрисоединенныхФайлов();
	
	Для Каждого ПолноеИмяСправочника Из ПолныеИменаСправочников Цикл
		ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведенийДляТаблицы(Параметры,
			ПолноеИмяСправочника, ОбработкаЗавершена);
	КонецЦикла;
	
	Параметры.ОбработкаЗавершена = ОбработкаЗавершена;
	
КонецПроцедуры

Функция ПолныеИменаСправочниковПрисоединенныхФайлов() Экспорт
	
	Массив = Новый Массив;
	
	Для Каждого ТипПрисоединенногоФайла Из Метаданные.ОпределяемыеТипы.ПрисоединенныйФайл.Тип.Типы() Цикл
		ПолноеИмя = Метаданные.НайтиПоТипу(ТипПрисоединенногоФайла).ПолноеИмя();
		Если СтрЗаканчиваетсяНа(ВРег(ПолноеИмя), ВРег("ВерсииПрисоединенныхФайлов")) Тогда
			Продолжить;
		КонецЕсли;
		Массив.Добавить(Метаданные.НайтиПоТипу(ТипПрисоединенногоФайла).ПолноеИмя());
	КонецЦикла;
	
	Если Массив.Найти("Справочник.Файлы") = Неопределено Тогда
		Массив.Добавить("Справочник.Файлы");
	КонецЕсли;
	
	Если Массив.Найти("Справочник.ВерсииФайлов") = Неопределено Тогда
		Массив.Добавить("Справочник.ВерсииФайлов");
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

Функция ИзменяемыеОбъектыПриПереносеЭлектронныхПодписейИСертификатовШифрования() Экспорт
	
	Возврат Метаданные.РегистрыСведений["ЭлектронныеПодписи"].ПолноеИмя() + ", "
	      + Метаданные.РегистрыСведений["СертификатыШифрования"].ПолноеИмя();
	
КонецФункции

// Позволяет перенести элементы табличных частей УдалитьЭлектронныеПодписи и УдалитьСертификатыШифрования
// в регистры сведений ЭлектронныеПодписи и СертификатыШифрования.
//
// Параметры:
//  ПараметрыОбновления        - Структура - структура параметров отложенного обработчика обновления.
//
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя объекта метаданных, из которого переносятся данные табличных частей
//                                        УдалитьЭлектронныеПодписи и УдалитьСертификатыШифрования.
//  ОбработкаЗавершена         - Булево - Истина, если обработаны все данные при обновлении ИБ.
//
Процедура ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведенийДляТаблицы(ПараметрыОбновления, ПолноеИмяОбъектаМетаданных, ОбработкаЗавершена)
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	
	Если ОбъектМетаданных = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Не указан объект для обработки электронных подписей и сертификатов шифрования.");
	КонецЕсли;
	
	ЕстьТабличнаяЧастьЭП = ОбъектМетаданных.ТабличныеЧасти.Найти("УдалитьЭлектронныеПодписи") <> Неопределено;
	ЕстьТабличнаяЧастьСШ = ОбъектМетаданных.ТабличныеЧасти.Найти("УдалитьСертификатыШифрования") <> Неопределено;
	
	ВыборкаСсылок = ОбновлениеИнформационнойБазы.ВыбратьСсылкиДляОбработки(ПараметрыОбновления.Очередь, ПолноеИмяОбъектаМетаданных);
	
	ОбъектовОбработано = 0;
	ПроблемныхОбъектов = 0;
	
	МассивСсылок = Новый Массив;
	
	НачатьТранзакцию();
	Попытка
		Пока ВыборкаСсылок.Следующий() Цикл
			МассивСсылок.Добавить(ВыборкаСсылок.Ссылка);
		КонецЦикла;
		
		Если ЕстьТабличнаяЧастьЭП Тогда
			ПеренестиДанныеЭлектроннойПодписиВРегистрСведений(МассивСсылок,
				ПолноеИмяОбъектаМетаданных, ОбъектМетаданных);
		КонецЕсли;
		
		Если ЕстьТабличнаяЧастьСШ Тогда
			ПеренестиДанныеСертификатовВРегистрСведений(МассивСсылок, ПолноеИмяОбъектаМетаданных);
		КонецЕсли;
		
		Для Каждого ОбъектСЭП Из МассивСсылок Цикл
			ОбновлениеИнформационнойБазы.ОтметитьВыполнениеОбработки(ОбъектСЭП);
		КонецЦикла;
		ОбъектовОбработано = МассивСсылок.Количество();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		// Если не удалось обработать какой-либо объект, требуется повторить попытку.
		ПроблемныхОбъектов = ПроблемныхОбъектов + МассивСсылок.Количество();
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось обработать объект: %1 по причине:
			           |%2'"),
			ОбъектМетаданных,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Предупреждение, ОбъектМетаданных, , ТекстСообщения);
	КонецПопытки;
	
	Если Не ОбновлениеИнформационнойБазы.ОбработкаДанныхЗавершена(ПараметрыОбновления.Очередь, ПолноеИмяОбъектаМетаданных) Тогда
		ОбработкаЗавершена = Ложь;
	КонецЕсли;
	
	Если ОбъектовОбработано = 0 И ПроблемныхОбъектов <> 0 Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Процедуре ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведений не удалось обработать некоторые объекты (пропущены): %1'"),
			ПроблемныхОбъектов);
		ВызватьИсключение ТекстСообщения;
	Иначе
		ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Информация,
			ОбъектМетаданных,
			,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Процедура ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведений обработала очередную порцию объектов: %1'"),
				ОбъектовОбработано));
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведенийДляТаблицы.
Процедура ПеренестиДанныеЭлектроннойПодписиВРегистрСведений(МассивОбъектов, ПолноеИмяОбъектаМетаданных, ОбъектМетаданных)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТЧЭлектронныеПодписи.Ссылка КАК ПодписанныйОбъект,
	|	ТЧЭлектронныеПодписи.ДатаПодписи,
	|	ТЧЭлектронныеПодписи.ИмяФайлаПодписи,
	|	ТЧЭлектронныеПодписи.Комментарий,
	|	ТЧЭлектронныеПодписи.КомуВыданСертификат,
	|	ТЧЭлектронныеПодписи.Отпечаток,
	|	ТЧЭлектронныеПодписи.Подпись,
	|	ТЧЭлектронныеПодписи.УстановившийПодпись,
	|	ТЧЭлектронныеПодписи.НомерСтроки КАК ПорядковыйНомер,
	|	ТЧЭлектронныеПодписи.Сертификат, 
	|	ТЧЭлектронныеПодписи.ПодписьВерна КАК ПодписьВерна,
	|	ТЧЭлектронныеПодписи.ДатаПроверкиПодписи КАК ДатаПроверкиПодписи
	|ИЗ
	|	" + ПолноеИмяОбъектаМетаданных + ".УдалитьЭлектронныеПодписи КАК ТЧЭлектронныеПодписи
	|ГДЕ
	|	ТЧЭлектронныеПодписи.Ссылка В(&МассивОбъектов)
	|ИТОГИ
	|	ПО ПодписанныйОбъект";
	
	Если ОбъектМетаданных = Метаданные.Справочники.ВерсииФайлов Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст,
			"ТЧЭлектронныеПодписи.Ссылка КАК ПодписанныйОбъект",
			"ТЧЭлектронныеПодписи.Ссылка.Владелец КАК ПодписанныйОбъект");
	КонецЕсли;
	
	РеквизитыТЧ = ОбъектМетаданных.ТабличныеЧасти.УдалитьЭлектронныеПодписи.Реквизиты;
	
	Если РеквизитыТЧ.Найти("ПодписьВерна") = Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТЧЭлектронныеПодписи.ПодписьВерна", "ЛОЖЬ");
	КонецЕсли;
	
	Если РеквизитыТЧ.Найти("ДатаПроверкиПодписи") = Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТЧЭлектронныеПодписи.ДатаПроверкиПодписи", "Неопределено");
	КонецЕсли;
	
	Запрос.УстановитьПараметр("МассивОбъектов", МассивОбъектов);
	Выгрузка = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Для Каждого Строка Из Выгрузка.Строки Цикл
		Если Не ЗначениеЗаполнено(Строка.ПодписанныйОбъект) Тогда
			Продолжить;
		КонецЕсли;
		НаборЗаписей = РегистрыСведений["ЭлектронныеПодписи"].СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.ПодписанныйОбъект.Установить(Строка.ПодписанныйОбъект);
		Для Каждого Подстрока Из Строка.Строки Цикл
			ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Подстрока);
		КонецЦикла;
		// Используется параллельное обновление с нестандартной отметкой выполнения обработанных данных.
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
		НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
		НаборЗаписей.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
		НаборЗаписей.Записать();
	КонецЦикла;
	
КонецПроцедуры

// Для процедуры ПеренестиЭлектронныеПодписиИСертификатыШифрованияВРегистрыСведенийДляТаблицы.
Процедура ПеренестиДанныеСертификатовВРегистрСведений(МассивОбъектов, ПолноеИмяОбъектаМетаданных)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТЧСертификатыШифрования.Ссылка КАК ЗашифрованныйОбъект,
	|	ТЧСертификатыШифрования.Отпечаток,
	|	ТЧСертификатыШифрования.Сертификат,
	|	ТЧСертификатыШифрования.НомерСтроки КАК ПорядковыйНомер,
	|	ТЧСертификатыШифрования.Представление
	|ИЗ
	|	" + ПолноеИмяОбъектаМетаданных + ".УдалитьСертификатыШифрования КАК ТЧСертификатыШифрования
	|ГДЕ
	|	ТЧСертификатыШифрования.Ссылка В(&МассивОбъектов)
	|ИТОГИ
	|	ПО ЗашифрованныйОбъект";
	
	Запрос.УстановитьПараметр("МассивОбъектов", МассивОбъектов);
	
	Выгрузка = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Для Каждого Строка Из Выгрузка.Строки Цикл
		НаборЗаписей = РегистрыСведений["СертификатыШифрования"].СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.ЗашифрованныйОбъект.Установить(Строка.ЗашифрованныйОбъект);
		Для Каждого Подстрока Из Строка.Строки Цикл
			ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Подстрока);
		КонецЦикла;
		// Используется параллельное обновление с нестандартной отметкой выполнения обработанных данных.
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
		НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
		НаборЗаписей.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
		НаборЗаписей.Записать();
	КонецЦикла;
	
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////////////////////////
///// Общие файловые функции
// См. эту процедуру в модуле РаботаСФайламиСлужебный.
Процедура ЗаписатьРезультатИзвлеченияТекста(ФайлИлиВерсияСсылка,
                                            РезультатИзвлечения,
                                            АдресВременногоХранилищаТекста) Экспорт
	
	РаботаСФайламиСлужебный.ЗаписатьРезультатИзвлеченияТекста(
		ФайлИлиВерсияСсылка,
		РезультатИзвлечения,
		АдресВременногоХранилищаТекста);
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ПроверитьПодписи(ИсходныеДанные, ДанныеСтрок) Экспорт
	
	ДатаПроверкиПодписи = ТекущаяДатаСеанса();
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		Возврат;
	КонецЕсли;
	МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
	
	МенеджерКриптографии = МодульЭлектроннаяПодпись.МенеджерКриптографии("ПроверкаПодписи");
	
	Для каждого СтрокаПодписи Из ДанныеСтрок Цикл
		ОписаниеОшибки = "";
		ПодписьВерна = МодульЭлектроннаяПодпись.ПроверитьПодпись(МенеджерКриптографии,
			ИсходныеДанные, СтрокаПодписи.АдресПодписи, ОписаниеОшибки, СтрокаПодписи.ДатаПодписи);
		
		СтрокаПодписи.ДатаПроверкиПодписи = ТекущаяДатаСеанса();
		СтрокаПодписи.ПодписьВерна   = ПодписьВерна;
		СтрокаПодписи.ОписаниеОшибки = ОписаниеОшибки;
		
		РаботаСФайламиСлужебныйКлиентСервер.ЗаполнитьСтатусПодписи(СтрокаПодписи);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает номер по нарастанию. Предыдущее значение берется из регистра сведений НомераОтсканированныхФайлов.
// Параметры:
// Владелец - ЛюбаяСсылка - владелец файла.
//
// Возвращаемое значение:
//   Число  - новый номер для сканирования.
//
Функция ПолучитьНовыйНомерДляСканирования(Владелец) Экспорт
	
	// Подготовить структуру отбора по измерениям.
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Владелец", Владелец);
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НомераОтсканированныхФайлов");
		ЭлементБлокировки.УстановитьЗначение("Владелец", Владелец);
		Блокировка.Заблокировать();
	
		// Получить структуру с данными ресурсов записи.
		СтруктураРесурсов = РегистрыСведений.НомераОтсканированныхФайлов.Получить(СтруктураОтбора);
		
		// Получить максимальный номер из регистра.
		Номер = СтруктураРесурсов.Номер;
		Номер = Номер + 1; // увеличим на 1
		
		// Запишем новый номер в регистр.
		НаборЗаписей = РегистрыСведений.НомераОтсканированныхФайлов.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Владелец.Установить(Владелец);
		
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Владелец = Владелец;
		НоваяЗапись.Номер = Номер;
		
		НаборЗаписей.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Номер;
	
КонецФункции

// Заносит номер в регистр сведений НомераОтсканированныхФайлов.
//
// Параметры:
// Владелец - ЛюбаяСсылка - владелец файла.
// НовыйНомер -  Число  - максимальный номер для сканирования.
//
Процедура ЗанестиМаксимальныйНомерДляСканирования(Владелец, НовыйНомер) Экспорт
	
	// Подготовить структуру отбора по измерениям.
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Владелец", Владелец);
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НомераОтсканированныхФайлов");
		ЭлементБлокировки.УстановитьЗначение("Владелец", Владелец);
		Блокировка.Заблокировать();   		
		
		// Получить структуру с данными ресурсов записи.
		СтруктураРесурсов = РегистрыСведений.НомераОтсканированныхФайлов.Получить(СтруктураОтбора);
		   
		// Получить максимальный номер из регистра.
		Номер = СтруктураРесурсов.Номер;
		Если НовыйНомер <= Номер Тогда // Кто-то другой уже записал бОльший номер.
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		Номер = НовыйНомер;
		
		// Запишем новый номер в регистр.
		НаборЗаписей = РегистрыСведений.НомераОтсканированныхФайлов.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Владелец.Установить(Владелец);
		
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Владелец = Владелец;
		НоваяЗапись.Номер = Номер;
		
		НаборЗаписей.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Функция ПоместитьФайлыВоВременноеХранилище(Параметры) Экспорт
	
	Перем ЗаписьZipФайла, ИмяАрхива;
	
	Результат = Новый Массив;
	
	ИмяВременнойПапки = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(ИмяВременнойПапки);
	ИспользованныеИменаФайлов = Новый Соответствие;
	
	Для Каждого ФайлВложение Из Параметры.МассивФайлов Цикл
		РаботаСФайламиСлужебный.СформироватьСписокФайловДляОтправкиПоПочте(Результат, ФайлВложение, Параметры.ИдентификаторФормы);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////////
// Печать табличного документа со штампом электронной подписи.

Функция ТабличныйДокументСоШтампом(СсылкаНаФайл, Ссылка) Экспорт
	
	ДанныеФайла    = РаботаСФайлами.ДанныеФайла(СсылкаНаФайл);
	ВременныйФайл = ПолучитьИмяВременногоФайла(".mxl");
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(ДанныеФайла.СсылкаНаДвоичныеДанныеФайла);
	ДвоичныеДанные.Записать(ВременныйФайл);
	
	ТабличныйДокумент = Новый ТабличныйДокумент;
	ТабличныйДокумент.Прочитать(ВременныйФайл);
	
	УдалитьФайлы(ВременныйФайл);
	
	МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
	
	ПараметрыШтампа = Новый Структура;
	ПараметрыШтампа.Вставить("ТекстОтметки", "");
	ПараметрыШтампа.Вставить("Логотип");
	
	ЭлектронныеПодписи = МодульЭлектроннаяПодпись.УстановленныеПодписи(Ссылка);
	
	ВладелецФайла = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "ВладелецФайла");
	
	СведенияОФайле = Новый Структура;
	СведенияОФайле.Вставить("ВладелецФайла", ВладелецФайла);
	
	Штампы = Новый Массив;
	Для Каждого Подпись Из ЭлектронныеПодписи Цикл
		Сертификат = Подпись.Сертификат;
		СертификатКриптографии = Новый СертификатКриптографии(Сертификат.Получить());
		РаботаСФайламиПереопределяемый.ПриПечатиФайлаСоШтампом(ПараметрыШтампа, СертификатКриптографии);
		
		Штамп = МодульЭлектроннаяПодпись.ШтампВизуализацииЭлектроннойПодписи(СертификатКриптографии,
			Подпись.ДатаПодписи, ПараметрыШтампа.ТекстОтметки, ПараметрыШтампа.Логотип);
		Штампы.Добавить(Штамп);
	КонецЦикла;
	
	МодульЭлектроннаяПодпись.ДобавитьШтампыВТабличныйДокумент(ТабличныйДокумент, Штампы);
	
	Возврат ТабличныйДокумент;
КонецФункции

#КонецОбласти
